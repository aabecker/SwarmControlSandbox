<!--
// Author: Shiva Shahrocki, Mable Wan, Lillian Lin, and Aaron T. Becker
// Started" 11/01/2014 -- present
// Description: This simulation controls n holonomic disk robots to push an object through a maze using the robot's mean position as feedback
/// uses a PD controller.
//
///////////////////////////////////////////////////////////////////////////////
-->
<html>
<head>
    <title>Stochastic Swarm Control: Box Pushing</title>
</head>
<body onload="init();">
    <canvas id="canvas" width="800" height="800" style="background-color:#EEEEEE;"></canvas>
    <div id="cc"></div>
</body>
<script type="text/javascript" src="../shared/Box2dWeb-2.1.a.3.min.js"></script> <!-- box2d -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script> <!-- forms & strings -->
<script type="text/javascript" src="../shared/jcanvas.min.js"></script>
<script type="text/javascript">
    // in Chrome, to view the console: Use the keyboard shortcut Command - Option - J (Mac) or Control -Shift -J (Windows/Linux).

    ///////////////////////////////
    //Begin Global Variables
    ///////////////////////////////
    var ROBOT_INPUT = {
        ROBOT_IDLE: 0x0,
        ROBOT_PROP: 0x01, //proportional control
        WAIT: 0x40
    };
    //drawing simulation frame
    var width = 800;
    var m_ControlInputY = 0;
    var mapXSize = 20;
    var mapYSize = 20;
    var mapScale = 40;
    var goalX = 5;
    var goalY = 18;
    var distX = 5;
    var distY = 18;
    var m_controlState = ROBOT_INPUT.ROBOT_IDLE;

    //object centroid
    var blockCOM_x = 0;
    var blockCOM_y = 0;

    // checking variables.
    var flagVar = false;
    var ifMDP = true;

    var goalRecieved = false; //reaching the goal status
    var timeFinished = 1000;
    var wroteFinish = false;

    var map = new Array(mapXSize);
    var map_MDP = new Array(mapXSize);
    var map_R = new Array(mapXSize);
    var map_prev = new Array(mapXSize);
    var policy_x = new Array(mapXSize);
    var policy_y = new Array(mapXSize);
    var policy_angle = new Array(mapXSize);
    //path planning
    var bestpayoff = -200;
    var payoff;
    var gamma = 0.97;
    var iteration = 0;
    var iteration_limit = 200;
    var probStraight = 0.5;

    var move_ysize = 9;
    var move_xsize = 2;
    var moves = new Array(move_ysize);
    var bestmove;
    var move;

    moves[0] = [1, 0];
    moves[1] = [1, 1];
    moves[2] = [0, 1];
    moves[3] = [-1, 1];
    moves[4] = [-1, 0];
    moves[5] = [-1, -1];
    moves[6] = [0, -1];
    moves[7] = [1, -1];
    moves[8] = [0, 0];

    var zeta = 2;//attractive constant
    var eta = 75;//repulsive constant
    var rhoNot = 3; //radius for attractive point
    var alphaWant = 0; //direction of object 
    var inside = 0; 
    var goalStartTime = null;

    var goalAngle = 2 / 8 * Math.PI;

    var k = [0, 2, 4, 6, 1, 3, 5, 7, 8];

    for (var i = 0; i < mapXSize; i++) {   // mapping data arrays
        map[i] = new Array(mapYSize);
        map_MDP[i] = new Array(mapYSize);
        map_R[i] = new Array(mapYSize);
        map_prev[i] = new Array(mapYSize);
        policy_x[i] = new Array(mapYSize);
        policy_y[i] = new Array(mapYSize);
        policy_angle[i] = new Array(mapYSize);
    }

    //.....policy_MDP...//
    //to determine the gradient for Markov Decision Process
    function policy_MDP(x, y) {
        var moveR, moveL;
        bestpayoff = -200;
        for (i = 0; i < k.length; i++) {
            var kval = k[i];
            move = moves[kval];
            if (kval < 7)
                moveR = moves[kval + 1];
            else
                moveR = moves[0];
            if (kval > 0)
                moveL = moves[kval - 1];
            else
                moveL = moves[7];
            if (move == [0, 0]) {
                moveR = [0, 0];
                moveL = [0, 0];
            }

            payoff = probStraight * (map_MDP[x + move[0]][y + move[1]]) + ((1 - probStraight) / 2) * (map_MDP[x + moveR[0]][y + moveR[1]]) + ((1 - probStraight) / 2) * (map_MDP[x + moveL[0]][y + moveL[1]]);
            //alert(payoff);*/

            if (payoff > bestpayoff) {
                bestpayoff = payoff;
                bestmove = move;
            }
        }
    }

    //Discretized regions
    var mainMaps = new Array(); //Main Region
    var transferMaps = new Array(); //Transfer Region
    var regionNum = null; 
    var regionMain = null; //The state the map is in
    var mostRobotRegion = null;
    var robotMain = null; 
    //Finds adjacent regions
    function findAdjRegion(regionMain, regionNum, x) {
        var adjRegions = new Array(2);
        if (regionMain) {
            if (regionNum == 0) {
                adjRegions[0] = 0; //adjacent region = transferRegion1
                adjRegions[1] = null;
            }
            else if (regionNum == 1) {
                adjRegions[0] = 0;
                adjRegions[1] = 1;
            } else if (regionNum == 2) {
                adjRegions[0] = 1;
                adjRegions[1] = null;
            }
        }
        if (!regionMain) {
            if (regionNum == 0) {
                adjRegions[0] = 0; //adjacent region = mainRegion1&2
                adjRegions[1] = 1;
            }
            else if (regionNum == 1) {
                adjRegions[0] = 1;
                adjRegions[1] = 2;
            }
        }
        if (x == 0) {
            return adjRegions[0];
        } else if (x == 1) {
            return adjRegions[1];
        }

    }

    //Variance control variables
    var max_desired_var_x = null;
    var min_desired_var_x = null; 
    var max_desired_var_y = max_desired_var_x;
    var min_desired_var_y = min_desired_var_x;

    //Object velocity properties
    var objAngularConst = 1;
    var objLinearConst = 1;

    //Creates a Box2D hexagon
    function makeHexagon(world, x, y, userData) {
        // create block
        // This defines a hexagon in CCW order.
        // http://blog.sethladd.com/2011/09/box2d-and-polygons-for-javascript.html
        var bodyDef = new Box2D.Dynamics.b2BodyDef;
        bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
        bodyDef.userData = userData;
        bodyDef.position.Set(x, y);

        var fixDef = new Box2D.Dynamics.b2FixtureDef();
        fixDef.density = 6.0;
        fixDef.friction = 0.8;
        fixDef.restitution = 0.2;  //bouncing value

        fixDef.isSensor = false;
        scale = 0.75;
        var Mpoints = [{ x: 1 * scale, y: 0 },
                            { x: 1 / 2 * scale, y: Math.sqrt(3) / 2 * scale },
                            { x: -1 / 2 * scale, y: Math.sqrt(3) / 2 * scale },
                            { x: -1 * scale, y: 0 },
                            { x: -1 / 2 * scale, y: -Math.sqrt(3) / 2 * scale },
                            { x: 1 / 2 * scale, y: -Math.sqrt(3) / 2 * scale }];
        var points = Mpoints.map(function _makeVecBased(pt) {
            return new Box2D.Common.Math.b2Vec2(2 * pt.x, 2 * pt.y);
        });

        fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape();
        fixDef.shape.SetAsArray(points, points.length);

        bodyDef.userData = 'moveable';
        var body = world.CreateBody(bodyDef);
        body.CreateFixture(fixDef);
        body.m_angularDamping = objAngularConst;
        body.m_linearDamping = objLinearConst;
        return body;
    }
    //Initialization
    function init() {
        var numrobots = 100; 
        var totalRobots = 100;

        //Creating Main Region Arrays
        mainMaps[0] = new Array(); 
        mainMaps[1] = new Array();
        mainMaps[2] = new Array();
        for (i = 0; i <= 20; i++) {
            mainMaps[0][i] = new Array();
            mainMaps[1][i] = new Array();
            mainMaps[2][i] = new Array();
        }
        for (i = 0; i <= 20; i++) {
            for (j = 0; j <= 20; j++) {
                mainMaps[0][i][j] = 0;
                mainMaps[1][i][j] = 0;
                mainMaps[2][i][j] = 0;
            }
        }
        for (x = 1; x <= 20; x++) {
            for (y = 13; y <= 20; y++) {
                mainMaps[0][x][y] = 1;
            }
        }
        for (x = 1; x <= 20; x++) {
            for (y = 7; y < 13; y++) {
                mainMaps[1][x][y] = 1;
            }
        }
        for (x = 1; x <= 20; x++) {
            for (y = 1; y < 7; y++) {
                mainMaps[2][x][y] = 1;
            }
        }
        //Creating Transfer Region Arrays
        transferMaps[0] = new Array();
        transferMaps[1] = new Array();
        for (i = 0; i <= 20; i++) {
            transferMaps[0][i] = new Array();
            transferMaps[1][i] = new Array();
        }
        for (i = 0; i <= 20; i++) { //setting the background to 0
            for (j = 0; j <= 20; j++) {
                transferMaps[0][i][j] = 0;
                transferMaps[1][i][j] = 0;
            }
        }
        for (x = 15; x <= 20; x++) {
            for (y = 7; y <= 20; y++) {
                transferMaps[0][x][y] = 1;
            }
        }
        for (x = 1; x <= 4; x++) {
            for (y = 1; y < 13; y++) {
                transferMaps[1][x][y] = 1;
            }
        }
        
        regionNum = 0;
        regionMain = true;
        var robotVar = false; 
        var minRobotCount = 50;
        var windowStopped = false;

        //Goal Positions
        var infinity = mapXSize * mapYSize;
        var mazeSize = 15;
        var mazeTopY = 13;
        var mazeDownY = 6;
        var goalPositionX = 16;
        var goalPositionY = 3;
        var goalPositionXDraw = 16.5;
        var goalPositionYDraw = 3.5;

        // Control variables for getting the robots unstuck from a corner
        var prev_mean_position_x = 0; 
        var prev_mean_position_y = 0;
        var start_timer = false;
        var stop_timer = true;
        var timer = 0;
        var timer_var = false;
        var robotVarTimer = false;
        var objMain = null;
        var corner = null;
        var mostRobotMainRegion = null;
        var secondMostRobotMainRegion = null;

        //variance corners
        var CornerValuesX = [1, 19, 19, 1, 1, 100];
        var CornerValuesY = [19, 19, 7, 13, 1, 100];
        var CornerValuesD = [51, 41, 30, 24, 17, 100];

        //Box2D 
        var b2Vec2 = Box2D.Common.Math.b2Vec2
        , b2AABB = Box2D.Collision.b2AABB
        , b2BodyDef = Box2D.Dynamics.b2BodyDef
        , b2Body = Box2D.Dynamics.b2Body
        , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
        , b2Fixture = Box2D.Dynamics.b2Fixture
        , b2World = Box2D.Dynamics.b2World
        , b2MassData = Box2D.Collision.Shapes.b2MassData
        , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
        , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
        , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
        , b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
        ;
        var world = new b2World(
            new b2Vec2(0, 00) //gravity setting to zero removes gravity
            , true //allow sleep
            );
        var canvas = $('#canvas');
        var context = canvas.get(0).getContext('2d');
        var timeStart = null;
        var timeFinish = null;
        var timer = null;
        var passed = null;
        var overall_time = null;
        var firstloop = true;
        var boundaryHeight = 2;
        var boundaryWidth = 20;
    
        //create enclosing boundary rectangles
        var fixDef = new b2FixtureDef;
        fixDef.density = 1.0;
        fixDef.friction = 0.5;
        fixDef.restitution = 0.25;
        var bodyDef = new b2BodyDef;
        bodyDef.userData = 'obstacle';
        bodyDef.type = b2Body.b2_staticBody;
        fixDef.shape = new b2PolygonShape;
        fixDef.shape.SetAsBox(20, 2);//width, height
        bodyDef.position.Set(10, width / mapScale + 1); //bottom
        var bodyBottom = world.CreateBody(bodyDef);
        bodyBottom.CreateFixture(fixDef);
        bodyDef.position.Set(10, -1); //top
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        fixDef.shape.SetAsBox(2, 14);//width, height
        bodyDef.position.Set(-1, 13); //left
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        bodyDef.position.Set(21, 13); // right side
        world.CreateBody(bodyDef).CreateFixture(fixDef);

        //Creating the maze
        bodyDef.userData = 'maze';
        fixDef.shape.SetAsBox(10, 0.5);//width, height
        bodyDef.position.Set(15, width / 4 / mapScale + 1.5); //TOP
        var bodyBottom = world.CreateBody(bodyDef);
        bodyBottom.CreateFixture(fixDef);
        bodyDef.position.Set(5, width * 2 / 3 / mapScale + 0.2); //BOTTOM
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        makeHexagon(world, 7, 15.5);
        bodyDef.userData = 'moveable';

        //create the robots
        bodyDef.type = b2Body.b2_dynamicBody;
        var robotrad = 0.15; 
        fixDef.density = 10.0;
        fixDef.friction = 2;
        fixDef.restitution = .5; //bouncing value
        fixDef.isSensor = false;
        var m_Robot = new Array();
        var rowLength = Math.floor(5 / (2 * robotrad));
        fixDef.shape = new b2CircleShape(robotrad);
        for (var i = 0; i < numrobots; ++i) {
            bodyDef.userData = 'robot';
            bodyDef.position.x = 1.5 + (i % rowLength) * 2 * robotrad;
            bodyDef.position.y = 18.5 - Math.floor(i / rowLength) * 2 * robotrad;
            m_Robot[i] = world.CreateBody(bodyDef);
            m_Robot[i].CreateFixture(fixDef);
            m_Robot[i].m_angularDamping = 1; //was 1, we used 10 on SwarmControl
            m_Robot[i].m_linearDamping = 1;
        }
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (/* function */ callback, /* DOMElement */ element) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();

        //Calculates MDP
        if (ifMDP) {
            for (var i = 0 ; i < mapXSize; i++) {
                map_MDP[i][0] = -100;
                map_MDP[i][mapYSize - 1] = -100;
                map_MDP[0][i] = -100;
                map_MDP[mapXSize - 1][i] = -100;

                map_R[i][0] = -50;
                map_R[i][mapYSize - 1] = -50;
                map_R[0][i] = -50;
                map_R[mapXSize - 1][i] = -50;

                map_prev[i][0] = 0;
                map_prev[i][mapYSize - 1] = 0;
                map_prev[0][i] = 0;
                map_prev[mapXSize - 1][i] = 0;

            }
            // giving -100 to obstacles.(Down Maze)
            for (var i = 0 ; i < mazeSize; i++) {
                map_MDP[i][mazeTopY] = -100;
                map_R[i][mazeTopY] = -50;
                map_prev[i][mazeTopY] = 0;
            }
            //Top Maze
            for (var i = mapXSize - 1 ; i > mapXSize - mazeSize - 1  ; i--) {
                map_MDP[i][mazeDownY] = -100;
                map_R[i][mazeDownY] = -50;
                map_prev[i][mazeDownY] = 0;
            }

            for (var i = 0 ; i < mapXSize ; i++) {
                for (var j = 0 ; j < mapYSize; j++) {
                    if (map_MDP[i][j] != -100) {
                        map_MDP[i][j] = -1;
                        map_R[i][j] = -1;
                        map_prev[i][j] = 0;
                    }
                }

            }
            map_MDP[goalPositionX][goalPositionY] = 100;
            map_R[goalPositionX][goalPositionY] = 100;

            while ((iteration < iteration_limit)) {
                map_prev = map_MDP;
                for (var i = 0; i < mapXSize; i++) {
                    for (var j = 0; j < mapYSize; j++) {
                        if (map_MDP[i][j] != -100) {
                            policy_MDP(i, j);
                            map_MDP[i][j] = gamma * (map_R[i][j] + bestpayoff);
                            policy_x[i][j] = -bestmove[0];
                            policy_y[i][j] = -bestmove[1];

                            policy_angle[i][j] = Math.atan2(policy_y[i][j], policy_x[i][j]) * 180 / Math.PI + 270;

                        }
                    }
                }
                iteration++;
            }
            ifMDP = false;
        }

        (function animloop() {
            requestAnimFrame(animloop);
            update();
        })();
        if (timeStart == null) {
            var day = new Date();
            timeStart = day.getTime();
        }
        //Calculates distance between two points
        function lineDistance(x1, y1, x2, y2) {
            var xs = 0;
            var ys = 0;
            xs = x1 - x2;
            xs = xs * xs;
            ys = y1 - y2;
            ys = ys * ys;
            return Math.sqrt(xs + ys);
        }
        //Main loops
        function update() {
            //
            var impulseV = new b2Vec2(0, 0);
            var impulse = 3.0;
            if (m_controlState & ROBOT_INPUT.ROBOT_PROP) {
                impulseV.x = m_ControlInputX;
                impulseV.y = m_ControlInputY;
            }

            //Calculate min and max desired variance constants
            var max_desired_var_x_constant = (.006) * vary + .45;
            if (vary < 50) {
                var min_desired_var_x_constant = max_desired_var_x_constant - .3;
            } else var min_desired_var_x_constant = max_desired_var_x_constant - .4;

            //Apply Brownian noise:
            var brownianImpulse = new b2Vec2(0, 0);
            var mag = 0;
            var ang = 0;
            var vary = 5;
            for (var i = 0; i < m_Robot.length; i++) {
                mag = vary * Math.random();
                ang = 2 * Math.PI * Math.random();
                brownianImpulse.x = mag * Math.cos(ang) + impulseV.x;
                brownianImpulse.y = mag * Math.sin(ang) + impulseV.y;
                m_Robot[i].ApplyForce(brownianImpulse, m_Robot[i].GetWorldPoint(new b2Vec2(0, 0)));
            }
            world.Step(1 / 60, 10, 10);
            world.DrawDebugData();
            world.ClearForces();

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            // BEGIN DRAWING FUNCTIONS
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            //Draw maze
            $("canvas").clearCanvas();
            $("canvas").rotateCanvas(
            {
                x: 5 * mapScale, y: 5 * mapScale,
                rotate: angle
            }).drawArc(
            {
                fillStyle: "green",
                x: 5 * mapScale, y: 5 * mapScale,
                radius: radius * mapScale
            }).drawArc(
            {
                strokeStyle: "#39FF14",
                strokeWidth: 7, 
                x: goalPositionXDraw * mapScale, y: goalPositionYDraw * mapScale,
                radius: 2.3 * mapScale
            }).drawText(
            {
                strokeStyle: "green",
                fillStyle: "green",
                strokeWidth: 2,
                x: goalPositionXDraw * mapScale, y: goalPositionYDraw * mapScale,
                fontSize: 30,
                fontFamily: 'Verdana, sans-serif',
                text: "Goal"
            }).restoreCanvas();

            //draw robots and obstacles
            function _drawRobot(x, y, angle, radius) {
                $("canvas").rotateCanvas(
                {
                    x: x * mapScale, y: y * mapScale,
                    rotate: angle
                })
                .drawArc(
                {
                    strokeStyle: "lightblue",
                    strokeWidth: 1,
                    fillStyle: "blue",
                    x: x * mapScale, y: y * mapScale,
                    radius: radius * mapScale
                })
                .restoreCanvas();
            }
            for (b = world.GetBodyList() ; b; b = b.GetNext()) {
                var angle = b.GetAngle() * (180 / Math.PI);
                var userData = b.GetUserData();
                var pos = b.GetPosition();
                for (f = b.GetFixtureList() ; f; f = f.GetNext()) {
                    if (userData == 'robot') {
                        var radius = f.GetShape().GetRadius();
                        _drawRobot(pos.x, pos.y, angle, radius);
                    }
                    else if (userData == 'obstacle' || userData == 'moveable' || userData == 'rectangle_ground' || userData == 'maze') {
                        if (userData != 'moveable') {
                            var X = f.GetShape().GetVertices()[1].x - f.GetShape().GetVertices()[0].x;
                            var Y = f.GetShape().GetVertices()[2].y - f.GetShape().GetVertices()[1].y;
                        }

                        if (userData == 'moveable') {
                            var color = 'black';
                            blockCOM_x = pos.x;
                            blockCOM_y = pos.y;

                            $("canvas")
                            .rotateCanvas({
                                x: pos.x * mapScale, y: pos.y * mapScale,
                                rotate: angle
                            })
                            .drawPolygon({
                                fillStyle: color,
                                x: pos.x * mapScale, y: pos.y * mapScale,
                                radius: 1.5 * mapScale,
                                sides: 6,
                                rotate: angle || 0
                            }).restoreCanvas();

                            continue;
                        } else if (userData == 'rectangle_ground') {
                            var color = 'green';
                        } else if (userData == 'maze') {
                            var color = 'brown';
                        } else if (userData == 'obstacle') {
                            var color = 'brown';
                        }

                        $("canvas").rotateCanvas({
                            x: pos.x * mapScale, y: pos.y * mapScale,
                            rotate: angle
                        })
                        .drawRect({
                            fillStyle: color,
                            x: pos.x * mapScale, y: pos.y * mapScale,
                            width: X * mapScale,
                            height: Y * mapScale,
                            cornerRadius: 0
                        })
                        .restoreCanvas();
                    }
                }
            }

            if (!goalRecieved) {
                $("canvas")
                .drawArc({
                    //draw the goal mean position
                    strokeStyle: "lightblue",
                    strokeWidth: 5,
                    x: goalX * mapScale, y: goalY * mapScale,
                    radius: radius * mapScale
                }).drawArc({
                    //draw the goal mean position
                    strokeStyle: "lightblue",
                    strokeWidth: 5,
                    x: goalX * mapScale, y: goalY * mapScale,
                    radius: (radius + 0.2) * mapScale
                }).restoreCanvas();
            }
            $("canvas").drawArc({
                //COM of the block
                strokeStyle: "orange",
                strokeWidth: 5,
                x: blockCOM_x * mapScale, y: blockCOM_y * mapScale,
                radius: radius * mapScale
            })
            .restoreCanvas();

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            // END DRAWING FUNCTIONS
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
 
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // CONTROLLER
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            //Timer
            var day = new Date();
            if (timeFinish == null && false)
            { timeFinish = day.getTime(); }
            if (overall_time == null) 
            {
                overall_time = day.getTime();
                goalStartTime = day.getTime();
            }
            var elapsedTimeSec = (day.getTime() - overall_time) / 1000;

            //goal positions
            var cycleInSec = 20;
            var amplitudeY = 5;
            var offsetY = 5;
            var amplitudeX = 5;
            var offsetX = 5;
            
            //Mean and covariance
            var sum_position_x = 0;
            var sum_position_y = 0;
            var sum2_x = 0;
            var sum2_y = 0;
            var desired_var_x;
            var cov_xy = 0;
            var block_x = Math.floor(blockCOM_x);
            var block_y = Math.floor(blockCOM_y);

            if (!isNaN(block_y)) { //Enters only if values are valid
                /*
                This section switches states in the state machine whenever the object moves out of the current region. 
                This section also calculates the number of robots in each region.
                */
                if (regionMain) { //If the state machine is in the main state
                    var blockPosition = mainMaps[regionNum][block_x][block_y];
                }
                if (!regionMain) {//If the state machine is in the transfer state
                    var blockPosition = transferMaps[regionNum][block_x][block_y];
                }
                if (blockPosition == 0) {
                    if (regionMain) {//if it's in the main region
                        regionMain = false; //switch to transfer regions
                        if (transferMaps[0][block_x][block_y] == 1) {
                            regionNum = 0; //checking which region the block is in
                        }
                        else if (transferMaps[1][block_x][block_y] == 1) {
                            regionNum = 1;
                        }
                    } else if (!regionMain) {
                        regionMain = true;
                        if (mainMaps[0][block_x][block_y] == 1) {
                            regionNum = 0;
                        } else if (mainMaps[1][block_x][block_y] == 1) {
                            regionNum = 1;
                        } else if (mainMaps[2][block_x][block_y] == 1) {
                            regionNum = 2;
                        }
                    }
                }
                numrobots = totalRobots;
                var regionRobotCount = 0;
                if (regionMain) {
                    for (var i = 0; i < numrobots; ++i) {
                        var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                        var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                        var pos = mainMaps[regionNum][pos_x][pos_y];
                        if (pos == 1) {
                            sum_position_x += m_Robot[i].GetPosition().x;
                            sum_position_y += m_Robot[i].GetPosition().y;
                            regionRobotCount = regionRobotCount + 1;
                        }
                    }
                }
                if (!regionMain) {
                    for (var i = 0; i < numrobots; ++i) {
                        var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                        var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                        var pos = transferMaps[regionNum][pos_x][pos_y];
                        if (pos == 1) {
                            sum_position_x += m_Robot[i].GetPosition().x;
                            sum_position_y += m_Robot[i].GetPosition().y;
                            regionRobotCount = regionRobotCount + 1;
                        }
                    }
                }
                numrobots = regionRobotCount;
                var mean_position_x = sum_position_x / numrobots;
                var mean_position_y = sum_position_y / numrobots;
                //Calculating covariance
                if (regionMain) {
                    for (var i = 0; i < numrobots; ++i) {
                        var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                        var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                        var pos = mainMaps[regionNum][pos_x][pos_y];
                        if (pos == 1) {
                            sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
                            sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
                            cov_xy = cov_xy + (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().y - mean_position_y) / numrobots;
                        }
                    }
                }
                if (!regionMain) {
                    for (var i = 0; i < numrobots; ++i) {
                        var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                        var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                        var pos = transferMaps[regionNum][pos_x][pos_y];
                        if (pos == 1) {
                            sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
                            sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
                            cov_xy = cov_xy + (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().y - mean_position_y) / numrobots;
                        }
                    }
                }
                max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;
                min_desired_var_x = numrobots * robotrad * min_desired_var_x_constant; 
                max_desired_var_y = max_desired_var_x;
                min_desired_var_y = min_desired_var_x;

                var var_x = sum2_x / numrobots;
                var var_y = sum2_y / numrobots;
                var diffeq = Math.sqrt((var_x - var_y) * (var_x - var_y) / 4 + cov_xy * cov_xy);
                var var_xp = (var_x + var_y) / 2 + diffeq;
                var var_yp = (var_x + var_y) / 2 - diffeq;
                var angle2 = 180 / Math.PI * 1 / 2 * Math.atan2(2 * cov_xy, var_x - var_y);
                var angle_min_variance = 180 / Math.PI * 1 / 2 * Math.atan2(2 * cov_xy, min_desired_var_x - min_desired_var_y);
                var angle_max_variance = 180 / Math.PI * 1 / 2 * Math.atan2(2 * cov_xy, max_desired_var_x - max_desired_var_y);
                var index_x = Math.floor(mean_position_x);
                var index_y = Math.floor(mean_position_y);
                
                //Controller to keep the number of robots in the region above zero. 
                //Having zero robots causes calculation errors
                minRobotCount = totalRobots / 2; //Threshold for minimum number of robots
                if ((regionRobotCount < minRobotCount)) {
                    robotVar = true;
                } else {
                    robotVar = false;
                    robotVarTimer = false;
                }
                if (robotVar && !robotVarTimer) {
                    ///////////////////////////////go to best corner to recollect when robots<15 in region
                    robotVarTimer = true;
                    var countMain0 = 0;
                    var countMain1 = 0;
                    var countMain2 = 0;
                    for (i = 0; i < totalRobots; i++) {
                        var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                        var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                        var pos0 = mainMaps[0][pos_x][pos_y];
                        var pos1 = mainMaps[1][pos_x][pos_y];
                        var pos2 = mainMaps[2][pos_x][pos_y];
                        if (pos0 == 1) {
                            countMain0++;
                        } else if (pos1 == 1) {
                            countMain1++;
                        } else if (pos2 == 1) {
                            countMain2++;
                        }
                    }
                    if ((countMain0 >= countMain1) && (countMain0 >= countMain2)) {
                        mostRobotMainRegion = 0;
                        if (countMain1 >= countMain2) {
                            secondMostRobotMainRegion = 1;
                        } else secondMostRobotMainRegion = 2;
                    }
                    else if ((countMain1 >= countMain0) && (countMain1 >= countMain2)) {
                        mostRobotMainRegion = 1;
                        if (countMain0 > countMain2) {
                            secondMostRobotMainRegion = 0;
                        } else secondMostRobotMainRegion = 2;
                    }
                    else if ((countMain2 >= countMain0) && (countMain2 > countMain1)) {
                        mostRobotMainRegion = 2;
                        if (countMain0 > countMain1) {
                            secondMostRobotMainRegion = 0;
                        } else secondMostRobotMainRegion = 1;
                    }
                    //finding which main region the block is in
                    var objPos0 = mainMaps[0][Math.floor(blockCOM_x)][Math.floor(blockCOM_y)];
                    var objPos1 = mainMaps[1][Math.floor(blockCOM_x)][Math.floor(blockCOM_y)];
                    var objPos2 = mainMaps[2][Math.floor(blockCOM_x)][Math.floor(blockCOM_y)];
                    if (objPos0 == 1) { objMain = 0; }
                    else if (objPos1 == 1) { objMain = 1; }
                    else { objMain = 2; }
                    //finding the right var corner
                }
                if (robotVar) {
                    if (objMain == 0) {
                        corner = 1;
                    } else if (objMain == 1) {
                        if (((mostRobotMainRegion == 0) || (secondMostRobotMainRegion == 0)) && ((mostRobotMainRegion == 1) || (secondMostRobotMainRegion == 1))) {
                            corner = 2;
                        } else if (((mostRobotMainRegion == 1) || (secondMostRobotMainRegion == 1)) && ((mostRobotMainRegion == 2) || (secondMostRobotMainRegion == 2)))
                            corner = 3;
                    } else corner = 4;
                    ////////////////////////////////////////
                    IndexMinDist = corner;
                    goalX = mean_position_x + Math.cos(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));
                    goalY = mean_position_y + Math.sin(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));
                }

                //for init- prev mean pos, start_timer=false, stop_timer=true; var timer=0;
                //for global var prev_mean pos
                //variance control if the mean stays in the same place
                if (stop_timer) {
                    timer = 0;
                    start_timer = true; //starts timer
                    stop_timer = false;
                    robotVarTime = false;
                }
                if (start_timer) {
                    timer = elapsedTimeSec; //gets starting point
                    prev_mean_position_x = mean_position_x; //get previous pos
                    prev_mean_position_y = mean_position_y;
                    start_timer = false;
                }
                if ((elapsedTimeSec - timer) > 5) {
                    var mean_difference_x = Math.abs(prev_mean_position_x - mean_position_x);
                    var mean_difference_y = Math.abs(prev_mean_position_y - mean_position_y);
                    //var mean_difference=Math.sqrt(mean_difference_x^2+mean_difference_y^2);
                    var mean_difference = lineDistance(mean_difference_x, mean_difference_y, 0, 0);

                    timer_var = false;
                    if (mean_difference < .1) {
                        flagVar = true;
                        timer_var = true;
                        stop_timer = true;
                    } else {
                        stop_timer = true; //stops timer
                        flagVar = false;
                    }
                }

                ////////////////////////////////
                if (!goalRecieved) {
                    $("canvas").drawEllipse({
                        strokeStyle: "red",
                        strokeWidth: 5,
                        setLineDash: 6,
                        x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                        width: 3 * 30 * Math.sqrt(var_xp), height: 3 * 30 * Math.sqrt(var_yp),
                        rotate: angle2
                    })
                    .restoreCanvas();
                } else {
                    var winstring = "Success,\n " + totalRobots + " robots in " + Math.floor(timeFinished) + "s";
                    goalRecieved = true;
                    $("canvas").drawText(
                    {
                        strokeStyle: "blue",
                        strokeWidth: 4,
                        x: 9 * mapScale, y: 10 * mapScale,
                        fontSize: 40,
                        fontFamily: 'Verdana, sans-serif',
                        text: winstring
                    }).restoreCanvas();
                }
                if (Math.abs(blockCOM_x - goalPositionX) < 2 && Math.abs(blockCOM_y - goalPositionY) < 2) {
                    goalRecieved = true;

                    if (wroteFinish == false) {
                        timeFinished = elapsedTimeSec;
                        wroteFinish = true;
                    }
                    m_controlState = ROBOT_INPUT.ROBOT_IDLE;
                }
                var block_difference = lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y);

                if (!goalRecieved) {
                    if (timer_var && (block_difference < 4) && (!robotVar)) {
                        min_desired_var_x = .1;
                        min_desired_var_y = min_desired_var_x;
                    } else if (!robotVar) {
                        max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
                        min_desired_var_x = numrobots * robotrad * min_desired_var_x_constant; //was .663
                        max_desired_var_y = max_desired_var_x;
                        min_desired_var_y = min_desired_var_x;
                    }

                    if (var_x < min_desired_var_x && var_y < min_desired_var_y) {
                        flagVar = false;
                    }
                    if (var_x > max_desired_var_x || var_y > max_desired_var_y) {
                        flagVar = true;
                    }

                    if (flagVar && !robotVar) {
                        if (!timer_var) {
                            if (regionMain)//if the object is in a main region
                            {
                                if (regionNum == 0) {
                                    IndexMinDist = 0;
                                } else if (regionNum == 1) {
                                    IndexMinDist = 2;
                                } else {
                                    IndexMinDist = 4;
                                }
                            }
                            else //if the object is in a transfer region
                            {
                                if (regionNum == 0) {
                                    IndexMinDist = 1;
                                } else {
                                    IndexMinDist = 3;
                                }
                            }
                        } else {
                            if (regionMain)//if the object is in a main region
                            {
                                if (regionNum == 0) {
                                    IndexMinDist = 1;
                                } else if (regionNum == 1) {
                                    IndexMinDist = 3;
                                } else {
                                    IndexMinDist = 5;
                                }
                            }
                            else //if the object is in a transfer region
                            {
                                if (regionNum == 0) {
                                    IndexMinDist = 2;
                                } else {
                                    IndexMinDist = 4;
                                }
                            }
                        }
                        goalX = mean_position_x + Math.cos(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));
                        goalY = mean_position_y + Math.sin(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));

                    }
                    if (!flagVar && !robotVar) {
                        var r = 0.8;
                        alphaWant = Math.atan2(policy_y[block_x][block_y], policy_x[block_x][block_y]);

                        attPointX = blockCOM_x - r * Math.cos(alphaWant + Math.PI);
                        attPointY = blockCOM_y - r * Math.sin(alphaWant + Math.PI);
                        repPointX = blockCOM_x;
                        repPointY = blockCOM_y;
                        if (1000 < day.getTime() - goalStartTime || firstloop) {
                            rho = lineDistance(mean_position_x, mean_position_y, repPointX, repPointY);

                            inside = inside + 1;

                            theta = Math.atan2(mean_position_y - repPointY, mean_position_x - repPointX);
                            angdiff = alphaWant - theta;
                            if (angdiff > Math.PI) { angdiff = angdiff - 2 * Math.PI };
                            if (angdiff < -Math.PI) { angdiff = angdiff + 2 * Math.PI };
                            var CGoal = 1;

                            if ((rho < rhoNot && Math.abs(angdiff) > (goalAngle)) && !robotVar) {
                                FrepX = eta * ((1 / rho) - (1 / rhoNot)) * (1 / rho) * (1 / rho) * (repPointX - mean_position_x);//change these lines
                                FrepY = eta * ((1 / rho) - (1 / rhoNot)) * (1 / rho) * (1 / rho) * (repPointY - mean_position_y);
                                rho = lineDistance(mean_position_x, mean_position_y, attPointX, attPointY);
                                FattX = zeta * (mean_position_x - attPointX) / rho;//change these lines
                                FattY = zeta * (mean_position_y - attPointY) / rho;
                                distX = -CGoal * Math.cos(Math.atan2(FattY + FrepY, FattX + FrepX));
                                distY = -CGoal * Math.sin(Math.atan2(FattY + FrepY, FattX + FrepX));
                                max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
                                max_desired_var_y = max_desired_var_x;
                            } else if (!robotVar) {
                                var COMdist2swarm = lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y);
                                if (COMdist2swarm < 1.5) {
                                    var r = 0.1;
                                } else var r = 0.8;
                                distX = CGoal * Math.cos(Math.atan2(blockCOM_y + r * policy_y[block_x][block_y] - mean_position_y, blockCOM_x + r * policy_x[block_x][block_y] - mean_position_x));
                                distY = CGoal * Math.sin(Math.atan2(blockCOM_y + r * policy_y[block_x][block_y] - mean_position_y, blockCOM_x + r * policy_x[block_x][block_y] - mean_position_x));
                                max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
                                max_desired_var_y = max_desired_var_x;
                            }
                            goalStartTime = day.getTime();
                        }
                        goalX = mean_position_x + distX;
                        goalY = mean_position_y + distY;
                    }

                    string = "Time = " + elapsedTimeSec + "s<br>inside # " + inside;
                    $('#cc').html(string); //USERDATA WILL SHOWN IN "div" WITH ID "cc"

                    $("canvas").drawArc({ //draw the average position
                        strokeStyle: "red",
                        strokeWidth: 5,
                        x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                        radius: radius * mapScale
                    })
                    .drawEllipse({
                        strokeStyle: "green",
                        strokeWidth: 5,
                        setLineDash: 6,
                        x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                        width: 3 * 30 * Math.sqrt(min_desired_var_x), height: 3 * 30 * Math.sqrt(min_desired_var_y),
                        rotate: angle2
                    })
                    .drawEllipse({
                        strokeStyle: "green",
                        strokeWidth: 5,
                        setLineDash: 6,
                        x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                        width: 3 * 30 * Math.sqrt(max_desired_var_x), height: 3 * 30 * Math.sqrt(max_desired_var_y),
                        rotate: angle2
                    }).restoreCanvas();

                    var Kgain = 10; //faster=bigger
                    var Kderivative = 1; //smaller=faster
                    var sum_velocity_x = 0;
                    var sum_velocity_y = 0;
                    for (var i = 0; i < numrobots; ++i) {
                        sum_velocity_x += m_Robot[i].GetLinearVelocity().x;
                        sum_velocity_y += m_Robot[i].GetLinearVelocity().y;
                    }
                    var mean_velocity_x = sum_velocity_x / numrobots;
                    var mean_velocity_y = sum_velocity_y / numrobots;
                    m_ControlInputY = Kgain * (goalY - mean_position_y) + Kderivative * (0 - mean_velocity_y);
                    m_ControlInputX = Kgain * (goalX - mean_position_x) + Kderivative * (0 - mean_velocity_x);
                    m_controlState = ROBOT_INPUT.ROBOT_PROP;
                }

                if (firstloop) { firstloop = false; }
            } else console.log("IsNAN");
        }; //end update
    };
</script>
<style>
    #cc {
        top: 600px;
        width: 600px;
        height: 200px;
        margin: 0;
        overflow: auto;
    }
</style>
</html>
