
<!--
This is just for getting a movie of the swarm writing the "swarm" !


////////////////////////////////////////////////////////////description//
// We want to control variance and mean position and find a way to the goal.
/////////////////////////////////////////////////////////////////////////
//
// Author: Shiva Shahrocki and Aaron T. Becker
// Started" 11/01/2014 -- present
// Description: controls the mean position of n holonomic disk robots using mean position as feedback
/// uses a PD controller.
//
// Records output into a log file/
//
// Status {working, broken, in progress, replacedby}: broken: controller works, but log files are not yet working
//
///////////////////////////////////////////////////////////////////////////////
-->
<html>
<link rel="ensemble icon" href="pictures/ATBensembleIcon.ico">
<head>
<title>Stochastic Swarm Control: Box Pushing</title>
</head>
<body onload="init();">
    <canvas id="canvas" width="800" height="600" style="background-color:#EEEEEE;"></canvas>
    <div id="cc"></div>
</body>
<body onload="instructions();">
<script type="text/javascript" src="../shared/Box2dWeb-2.1.a.3.min.js"></script> <!-- box2d -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script> <!-- forms & strings -->
<script type="text/javascript" src="../shared/jcanvas.min.js"></script>
<script type="text/javascript">
// in Chrome, to view the console: Use the keyboard shortcut Command - Option - J (Mac) or Control -Shift -J (Windows/Linux).

    //refreshing the page
function refresh() {
    location.reload();
}

//creating the instructional page
function instructions() {
    //welcome!!!
    var winstring = "Mean Control Game";
    $("canvas").drawText(
    {
        fillStyle:"Red",
        strokeStyle: "Red",
        strokeWidth: 3,
        x: 9 * mapScale,
        y: 3 * mapScale,
        fontSize: 50,
        fontFamily: 'Verdana, sans-serif',
        text: winstring
    }).restoreCanvas();

    var winstring = "Description: Users manipulate swarm robots (blue dots) to align \n     the mean target (red dot) with the goal position (light blue target). \nThe goal is to active the green blocks to spell out \"SWARM.\" \n       Observe how the number of robots change the \n      difficulty of controlling the mean center.";
    $("canvas").drawText(
    {
        strokeStyle: "Blue",
        strokeWidth: 2,
        x: 9.5 * mapScale,
        y: 6 * mapScale,
        fontSize: 20,
        fontFamily: 'Verdana, sans-serif',
        text: winstring
    }).restoreCanvas();

    var winstring = "Select your level below and let's PLAY!";
    $("canvas").drawText(
    {
        strokeStyle: "LightSkyBlue",
        strokeWidth: 2,
        x: 9 * mapScale,
        y: 9 * mapScale,
        fontSize: 25,
        fontFamily: 'Verdana, sans-serif',
        text: winstring
    }).restoreCanvas();

}

///////////////////////////////
//Begin Global Variables
///////////////////////////////
var ROBOT_INPUT = { //robot commands
    ROBOT_IDLE: 0x0,
	ROBOT_LEFT    : 0x1, 
	ROBOT_RIGHT   : 0x2, 
	ROBOT_UP     : 0x4, 
	ROBOT_DOWN     : 0x8,
	WAIT : 0x40
};


var Level = [7, 6, 5, 4, 3, 2, 1];
var levelTimes = [];
var Time_Score = 0; //time played
var Time_Score_Boo = false;
var Time_Score_Stop;

var vary = 1; //Brownian noise variable
var width = 600;
var m_ControlInputY = 0;

var m_controlState = ROBOT_INPUT.ROBOT_IDLE;
var mapXSize = 20;
var mapYSize = 20;
var mapScale = 40;

var blockCOM_x = 0;
var blockCOM_y = 0;
// checking variables.
var flagVar = false;
var ifBFS = true;
var ifGradient = true;
// Debugging Variables.
var BFSDebugMode = false;
var Gradient_DebugMode = false;
var goalRecieved = false;  //have we reached the goal?
var timeFinished = 1000;
var wroteFinish = false;

var numberOfGoals = 60;

var map = new Array(mapXSize);
var gradient_x = new Array(mapXSize);
var gradient_y = new Array(mapXSize);
var gradient_angle = new Array(mapXSize);

var goalsX = new Array(numberOfGoals); //these array spell out SWARM
var goalsY = new Array(numberOfGoals);

var index_goal = 0; //current goal position
var done = false;


for (var i = 0; i < mapXSize; i++) 
{   // mapping data arrays
	map[i] = new Array(mapYSize);
	gradient_x[i] = new Array(mapYSize);
	gradient_y[i] = new Array(mapYSize);
	gradient_angle[i] = new Array(mapYSize);
}

///// S
goalsX[0] = 10;
goalsY[0] = 17;
goalsX[1] = 9;
goalsY[1] = 17;
goalsX[2] = 8;
goalsY[2] = 17;
goalsX[3] = 8;
goalsY[3] = 18;
goalsX[4] = 8;
goalsY[4] = 19;
goalsX[5] = 9;
goalsY[5] = 19;
goalsX[6] = 10;
goalsY[6] = 19;
goalsX[7] = 10;
goalsY[7] = 20;
goalsX[8] = 10;
goalsY[8] = 21;
goalsX[9] = 9;
goalsY[9] = 21;
goalsX[10] = 8;
goalsY[10] = 21;

var offsetGoalY = 2;
var offsetGoalX = 0.5;
var goalX = goalsX[0]/2- offsetGoalX;
var goalY = goalsY[0]/2 -offsetGoalY;


/////////////////////////////
//End Global Variables
/////////////////////////////

/////////////////////////////
//Begin Algorithmic Functions
/////////////////////////////

////////////////////////////
//End Algorithmic Functions
////////////////////////////

///////////////////////////
//Begin Drawing Functions
///////////////////////////


///////////////////////////
//End Drawing Functions
///////////////////////////

function init(numrobotsB) 
{
    numrobotsB = 100;
    var b2Vec2 = Box2D.Common.Math.b2Vec2
	, b2AABB = Box2D.Collision.b2AABB
	, b2BodyDef = Box2D.Dynamics.b2BodyDef
	, b2Body = Box2D.Dynamics.b2Body
	, b2FixtureDef = Box2D.Dynamics.b2FixtureDef
	, b2Fixture = Box2D.Dynamics.b2Fixture
	, b2World = Box2D.Dynamics.b2World
	, b2MassData = Box2D.Collision.Shapes.b2MassData
	, b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
	, b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
	, b2DebugDraw = Box2D.Dynamics.b2DebugDraw
	, b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
    ;
    var time_stop = true;//stops the timer when game finishes

    var world = new b2World(
		new b2Vec2(0, 00) //gravity setting to zero removes gravity
		, true //allow sleep
		);
    var canvas = $('#canvas');
    var context = canvas.get(0).getContext('2d');
    var timeStart = null;
    var timeFinish = null;
    var timer = null;
    var passed = null;
    var overall_time = null;
    var firstloop = false;
    var boundaryHeight = 2;
    var boundaryWidth = 20;

    var fixDef = new b2FixtureDef;
    fixDef.density = 1.0;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2; //bouncing value
    var bodyDef = new b2BodyDef;
 
    //create enclosing boundary rectangles
    bodyDef.userData = 'obstacle';
    bodyDef.type = b2Body.b2_staticBody;
    fixDef.shape = new b2PolygonShape;
    fixDef.shape.SetAsBox(20, 2);//width, height
    bodyDef.position.Set(10, width / mapScale + 1); //bottom
    var bodyBottom = world.CreateBody(bodyDef);
    bodyBottom.CreateFixture(fixDef);
    bodyDef.position.Set(10, -1); //top
    world.CreateBody(bodyDef).CreateFixture(fixDef);
    fixDef.shape.SetAsBox(2, 14);//width, height
    bodyDef.position.Set(-1, 13); //left
    world.CreateBody(bodyDef).CreateFixture(fixDef);
    bodyDef.position.Set(21, 13); // right side
    world.CreateBody(bodyDef).CreateFixture(fixDef);

    ////create the robots
    var numrobots = numrobotsB;//saving the function parameter
    bodyDef.type = b2Body.b2_dynamicBody;
    var robotrad = 0.1; //for SwarmControl.net, we used 0.2;
    if (BFSDebugMode || Gradient_DebugMode) {
        numrobots = 0;
    }
    fixDef.density = 1.0;
    fixDef.friction = 7; //was .5
    fixDef.restitution = 1.3; //bouncing value was .2
    fixDef.isSensor = false;
    var m_Robot = new Array();
    var rowLength = Math.floor(5 / (2 * robotrad));
    fixDef.shape = new b2CircleShape(robotrad);
    for (var i = 0; i < numrobots; ++i) {
        bodyDef.userData = 'robot';
        bodyDef.position.x = 3 + (i % rowLength) * 2 * robotrad;
        bodyDef.position.y = 7 - Math.floor(i / rowLength) * 2 * robotrad;
        m_Robot[i] = world.CreateBody(bodyDef);
        m_Robot[i].CreateFixture(fixDef);
        m_Robot[i].m_angularDamping = 1; //was 1, we used 10 on SwarmControl
        m_Robot[i].m_linearDamping = 1
    }

    window.requestAnimFrame = (function () {
        return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (/* function */ callback, /* DOMElement */ element) {
            window.setTimeout(callback, 1000 / 60);
        };
    })();

    ///////////////////////////////////
    // Brushfire Algorithm
    ///////////////////////////////////
    var infinity = mapXSize * mapYSize;
    var mazeSize = 15;
    var mazeTopY = 13;
    var mazeDownY = 6;
    var goalPositionX = 16;
    var goalPositionY = 3;
    var goalPositionXDraw = 16.5;
    var goalPositionYDraw = 3.5;

    //redraws the bouncing balls
    (function animloop() {
        requestAnimFrame(animloop);
        update(numrobots);
    })();
    if (timeStart == null) {
        var day = new Date();
        timeStart = day.getTime();
    }

    //called each animation round
    //y-axis is inverted in webpage
    function update(numrobotsB) 
    {
        var numrobots = numrobotsB; //saving function parameter
        var impulseV=new b2Vec2(0,0);
        var impulse = 1.0;
		
        //allows users to control the robots with arrow keys
        document.addEventListener("keydown",function(e){
            switch(e.keyCode){ // |= sets
                case 37: m_controlState |= ROBOT_INPUT.ROBOT_LEFT; break; 
                case 38: m_controlState |= ROBOT_INPUT.ROBOT_UP; break;
                case 39: m_controlState |= ROBOT_INPUT.ROBOT_RIGHT; break;
                case 40: m_controlState |= ROBOT_INPUT.ROBOT_DOWN; break;
            }
        })
		
        document.addEventListener("keyup",function(e){
            switch(e.keyCode){ // &=~ resets
                case 37: m_controlState &= ~ROBOT_INPUT.ROBOT_LEFT; break;
                case 38: m_controlState &= ~ROBOT_INPUT.ROBOT_UP; break;
                case 39: m_controlState &= ~ROBOT_INPUT.ROBOT_RIGHT; break;
                case 40: m_controlState &= ~ROBOT_INPUT.ROBOT_DOWN; break;
            }
        })
        //adds velocity to robots based on array key input
        if (m_controlState == ROBOT_INPUT.ROBOT_LEFT)
        {impulseV.x-=impulse;}
        if (m_controlState == ROBOT_INPUT.ROBOT_UP)
        {impulseV.y-=impulse;}
        if (m_controlState == ROBOT_INPUT.ROBOT_RIGHT)
        {impulseV.x+=impulse;}
        if (m_controlState == ROBOT_INPUT.ROBOT_DOWN)
        { impulseV.y += impulse; }

        //allows for multiple key presses 
        if (m_controlState & ROBOT_INPUT.ROBOT_LEFT)
        { impulseV.x -= impulse; }
        if (m_controlState & ROBOT_INPUT.ROBOT_UP)
        { impulseV.y -= impulse; }
        if (m_controlState & ROBOT_INPUT.ROBOT_RIGHT)
        { impulseV.x += impulse; }
        if (m_controlState & ROBOT_INPUT.ROBOT_DOWN)
        { impulseV.y += impulse; }
        //normalize
        var denom = Math.sqrt(impulseV.x * impulseV.x + impulseV.y * impulseV.y);
        if (denom > impulse) {
            impulseV.x = impulseV.x / denom;
            impulseV.y = impulseV.y / denom;
        }



        //apply Brownian noise:
        var brownianImpulse = new b2Vec2(0, 0);
        var mag = 0;
        var ang = 0;
        //vary= 1; //was 1
        for (var i = 0; i < m_Robot.length; i++) {
            mag = vary * Math.random();
            ang = 2 * Math.PI * Math.random();
            brownianImpulse.x = mag * Math.cos(ang) + impulseV.x;
            brownianImpulse.y = mag * Math.sin(ang) + impulseV.y;
            m_Robot[i].ApplyForce(brownianImpulse, m_Robot[i].GetWorldPoint(new b2Vec2(0, 0)));
        }

        world.Step(1 / 60, 10, 10);
        world.DrawDebugData();
        world.ClearForces();
        $("canvas").clearCanvas();
        $("canvas").rotateCanvas(
        {
            x: 5 * mapScale, y: 5 * mapScale,
            rotate: angle
        }).restoreCanvas();
        //draw robots and obstacles
        for (b = world.GetBodyList() ; b; b = b.GetNext()) {
            var angle = b.GetAngle() * (180 / Math.PI);
            for (f = b.GetFixtureList() ; f; f = f.GetNext()) {
                if (b.GetUserData() == 'robot') {

                    var radius = f.GetShape().GetRadius();
                    var pos = b.GetPosition();
                    $("canvas")
                    .rotateCanvas(
                    {
                        x: pos.x * mapScale, y: pos.y * mapScale,
                        rotate: angle
                    })
                    .drawArc(
                    {
                        strokeStyle: "lightblue",
                        strokeWidth: 1,
                        fillStyle: "blue",
                        x: pos.x * mapScale, y: pos.y * mapScale,
                        radius: radius * mapScale
                    })
                    .restoreCanvas();
                }
                else if (b.GetUserData() == 'obstacle' || b.GetUserData() == 'moveable' || b.GetUserData() == 'rectangle_ground') {
                    var X = f.GetShape().GetVertices()[1].x - f.GetShape().GetVertices()[0].x;
                    var Y = f.GetShape().GetVertices()[2].y - f.GetShape().GetVertices()[1].y;
                    //console.log(X);
                    var pos = b.GetPosition();
                    var color = 'orange';
                    if (b.GetUserData() == 'obstacle')
                        color = 'brown';
                    if (b.GetUserData() == 'moveable') {
                        color = 'black';
                        blockCOM_x = pos.x;
                        blockCOM_y = pos.y;
                    }
                    $("canvas")
                    .rotateCanvas({
                        x: pos.x * mapScale, y: pos.y * mapScale,
                        rotate: angle
                    })
                    .drawRect({
                        fillStyle: color,
                        x: pos.x * mapScale, y: pos.y * mapScale,
                        width: X * mapScale,
                        height: Y * mapScale,
                        cornerRadius: 0
                    })
                    .restoreCanvas();
                    if (BFSDebugMode || Gradient_DebugMode) {
                        for (var i = 0 ; i < 20; i++) {
                            $("canvas")
                            .drawLine(
                            {
                                strokeStyle: 'gray',
                                strokeWidth: 1,
                                x1: i * mapScale, y1: 0,
                                x2: i * mapScale, y2: 20 * mapScale
                            })
                            .drawLine({
                                strokeStyle: 'gray',
                                strokeWidth: 1,
                                x1: 0, y1: i * mapScale,
                                x2: 20 * mapScale, y2: i * mapScale
                            })
                        }
                        $("canvas").restoreCanvas();
                    }
                }
            }
        }
		    
    //prevents screen from moving around with arrow keys
    window.addEventListener("keydown", function (e) {
        if ([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
            e.preventDefault();
        }
    }, false);


}

    };
    //end update
</script>
<style>
#cc	{
	top: 600px;
	width: 600px;
	height: 200px;
	margin: 0;
	overflow: auto;
}
</style>
</html>

