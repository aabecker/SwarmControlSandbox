<!--
// Author: Shiva Shahrocki, Mable Wan, Lillian Lin, and Aaron T. Becker
// Started" 11/01/2014 -- present
// Description: This simulation controls n holonomic disk robots to push an object through a maze using the robot's mean position as feedback
/// in a PD controller.
//
///////////////////////////////////////////////////////////////////////////////
-->
<html>
<head>
    <title>Stochastic Swarm Control: Box Pushing</title>
</head>
<body onload="init();">
    <canvas id="canvas" width="800" height="800" style="background-color:#EEEEEE;"></canvas>
    <div id="cc"></div>
</body>
<script type="text/javascript" src="../shared/Box2dWeb-2.1.a.3.min.js"></script> <!-- box2d -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script> <!-- forms & strings -->
<script type="text/javascript" src="../shared/jcanvas.min.js"></script>
<script type="text/javascript">
    // in Chrome, to view the console: Use the keyboard shortcut Command - Option - J (Mac) or Control -Shift -J (Windows/Linux).

    ///////////////////////////////
    //Begin Global Variables
    ///////////////////////////////
    var ROBOT_INPUT = {
        ROBOT_IDLE: 0x0,
        ROBOT_PROP: 0x01, //proportional control
        WAIT: 0x40
    };

    var width = 800;
    var m_ControlInputY = 0;
    var mapXSize = 20;
    var mapYSize = 20;
    var mapScale = 40;
    var goalX = 5;
    var goalY = 18;
    var distX = 5;
    var distY = 18;
    var m_controlState = ROBOT_INPUT.ROBOT_IDLE;

    var blockCOM_x = 0;
    var blockCOM_y = 0;

    // checking variables.
    var flagVar = false; //Flags variance control
    var ifMDP = true;
    var ifGradient = false;
    var ifBFS = true;

    // Debugging Variables.
    var MDP_DebugMode = false;
    var BFSDebugMode = false;
    var Gradient_DebugMode = false;
    var Gradient_DebugMode_MDP = false;
    var goalRecieved = false;  //have we reached the goal?
    var timeFinished = 1000;
    var wroteFinish = false;

    var map = new Array(mapXSize);
    var map_MDP = new Array(mapXSize);
    var map_R = new Array(mapXSize);
    var map_prev = new Array(mapXSize);
    var gradient_x = new Array(mapXSize);
    var gradient_y = new Array(mapXSize);
    var gradient_angle = new Array(mapXSize);
    var policy_x = new Array(mapXSize);
    var policy_y = new Array(mapXSize);
    var policy_angle = new Array(mapXSize);

    var bestpayoff = -200;
    var payoff;
    var gamma = 0.97;
    var iteration = 0;
    var iteration_limit = 200;
    var probStraight = 0.5;

    var move_ysize = 9;
    var move_xsize = 2;
    var moves = new Array(move_ysize);
    var bestmove;
    var move;

    moves[0] = [1, 0];
    moves[1] = [1, 1];
    moves[2] = [0, 1];
    moves[3] = [-1, 1];
    moves[4] = [-1, 0];
    moves[5] = [-1, -1];
    moves[6] = [0, -1];
    moves[7] = [1, -1];
    moves[8] = [0, 0];

    var zeta = 2;//attractive
    var eta = 75;//repulsive
    var rhoNot = 3; //radius for flow around was 3
    var rho = 0;
    var alphaWant = 0;
    var inside = 0;
    var goalStartTime = null;

    var goalAngle = 2 / 8 * Math.PI;

    var k = [0, 2, 4, 6, 1, 3, 5, 7, 8];

    for (var i = 0; i < mapXSize; i++) {   // mapping data arrays
        map[i] = new Array(mapYSize);
        map_MDP[i] = new Array(mapYSize);
        map_R[i] = new Array(mapYSize);
        map_prev[i] = new Array(mapYSize);
        gradient_x[i] = new Array(mapYSize);
        gradient_y[i] = new Array(mapYSize);
        gradient_angle[i] = new Array(mapYSize);
        policy_x[i] = new Array(mapYSize);
        policy_y[i] = new Array(mapYSize);
        policy_angle[i] = new Array(mapYSize);
    }

    /////////////////////////////
    //End Global Variables
    /////////////////////////////

    /////////////////////////////
    //Begin Algorithmic Functions
    /////////////////////////////


    //.....policy_MDP...//


    function BFS(x, y) {  //recursively compute Breadth First Search from goal to every other grid cell
        var dist = map[x][y];
        if (dist == -1) // this is an obstacle region
        { return; }
        if (x - 1 > 0) {
            if (map[x - 1][y] > dist + 1) {
                map[x - 1][y] = dist + 1;
                BFS(x - 1, y);
            }
        }
        if (y + 1 < mapYSize) {
            if (map[x][y + 1] > dist + 1) {
                map[x][y + 1] = dist + 1;
                BFS(x, y + 1);
            }
        }
        if (y - 1 > 0) {
            if (map[x][y - 1] > dist + 1) {
                map[x][y - 1] = dist + 1;
                BFS(x, y - 1);
            }
        }
        if (x + 1 < mapXSize) {
            if (map[x + 1][y] > dist + 1) {
                map[x + 1][y] = dist + 1;
                BFS(x + 1, y);
            }
        }
    }

    function Gradient(x, y) {  // computes the x and y gradient of cell(x,y)  requires a map with distance values.
        var dist = map[x][y];
        if (dist == -1) {
            gradient_x[x][y] = 0;
            gradient_y[x][y] = 0;
            return;
        }

        if (map[x - 1][y] == -1 && map[x + 1][y] == -1) {
            gradient_x[x][y] = 0;
        }
        else if (map[x - 1][y] == -1) {
            gradient_x[x][y] = map[x + 1][y] - map[x][y];
        }
        else if (map[x + 1][y] == -1) {
            gradient_x[x][y] = map[x][y] - map[x - 1][y];
        }
        else {
            gradient_x[x][y] = (map[x + 1][y] - map[x - 1][y]) / 2;
        }
        if (map[x][y - 1] == -1 && map[x][y + 1] == -1) {
            gradient_y[x][y] = 0;
        }
        else if (map[x][y - 1] == -1) {
            gradient_y[x][y] = 0;//map[x][y+1] - map[x][y];
        }
        else if (map[x][y + 1] == -1) {
            gradient_y[x][y] = map[x][y] - map[x][y - 1];
        }
        else {
            gradient_y[x][y] = (map[x][y + 1] - map[x][y - 1]) / 2;
        }

        gradient_angle[x][y] = Math.atan2(gradient_y[x][y], gradient_x[x][y]) * 180 / Math.PI + 270;
    }

    //to determine the gradient for Markov Decision Process

    function policy_MDP(x, y) {
        var moveR, moveL;
        bestpayoff = -200;
        for (i = 0; i < k.length; i++) {
            var kval = k[i];
            move = moves[kval];
            if (kval < 7)
                moveR = moves[kval + 1];
            else
                moveR = moves[0];
            if (kval > 0)
                moveL = moves[kval - 1];
            else
                moveL = moves[7];
            if (move == [0, 0]) {
                moveR = [0, 0];
                moveL = [0, 0];
            }

            payoff = probStraight * (map_MDP[x + move[0]][y + move[1]]) + ((1 - probStraight) / 2) * (map_MDP[x + moveR[0]][y + moveR[1]]) + ((1 - probStraight) / 2) * (map_MDP[x + moveL[0]][y + moveL[1]]);
            //alert(payoff);*/

            if (payoff > bestpayoff) {
                bestpayoff = payoff;
                bestmove = move;
            }
        }
    }

    ////////////////////////////
    //End Algorithmic Functions
    ////////////////////////////

    ///////////////////////////
    //Begin Drawing Functions
    ///////////////////////////

    function calcPointsCirc(cx, cy, rad, dashLength) {  //Draw a dashed circle
        var n = rad / dashLength,
        alpha = Math.PI * 2 / n,
        pointObj = {},
        points = [],
        i = -1;
        while (i < n) {
            var theta = alpha * i,
            theta2 = alpha * (i + 1);
            points.push({ x: (Math.cos(theta) * rad) + cx, y: (Math.sin(theta) * rad) + cy, ex: (Math.cos(theta2) * rad) + cx, ey: (Math.sin(theta2) * rad) + cy });
            i += 2;
        }
        return points;
    }

    //Variables for simulation tests
    var testing = false; //Turn on to simulate and save results
    var testRobots = false; //Changes number of robots
    var testNoise = false; //Changes brownian noise
    var testObj = false; //Changes obj's angular/linear Const

    var TestShapes = false; //Turn on to save results
    var Circle = false; //Set the desired shape to true
    var Square = false;
    var Hexagon = false;
    var shortRect = true;
    var longRect = false;
    //Triangle doesn't work here. Go to file ObjectManipulation Triangle for simulation
    var Triangle = false; 

    //Discretizing the maze into regions: Main and Transfer
    var regionNum = null; //The region the object is in
    var regionMain = null; //The state that the object is in, main or transfer

    var max_desired_var_x = null;
    var min_desired_var_x = null; 
    var max_desired_var_y = max_desired_var_x;
    var min_desired_var_y = min_desired_var_x;
    var objAngularConst = 1;
    var objLinearConst = 1;

    ///////////////////////////
    //End Drawing Functions
    ///////////////////////////

    function makeHexagon(world, x, y, userData) {
        // create block
        // This defines a hexagon in CCW order.
        // http://blog.sethladd.com/2011/09/box2d-and-polygons-for-javascript.html
        var bodyDef = new Box2D.Dynamics.b2BodyDef;
        bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
        bodyDef.userData = userData;
        bodyDef.position.Set(x, y);

        var fixDef = new Box2D.Dynamics.b2FixtureDef();
        fixDef.density = 6.0;
        fixDef.friction = 0.8;
        fixDef.restitution = 0.2;  //bouncing value

        fixDef.isSensor = false;
        scale = 0.75;
        var Mpoints = [{ x: 1 * scale, y: 0 },
                            { x: 1 / 2 * scale, y: Math.sqrt(3) / 2 * scale },
                            { x: -1 / 2 * scale, y: Math.sqrt(3) / 2 * scale },
                            { x: -1 * scale, y: 0 },
                            { x: -1 / 2 * scale, y: -Math.sqrt(3) / 2 * scale },
                            { x: 1 / 2 * scale, y: -Math.sqrt(3) / 2 * scale }];
        var points = Mpoints.map(function _makeVecBased(pt) {
            return new Box2D.Common.Math.b2Vec2(2 * pt.x, 2 * pt.y);
        });

        fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape();
        fixDef.shape.SetAsArray(points, points.length);

        bodyDef.userData = 'moveable';
        var body = world.CreateBody(bodyDef);
        body.CreateFixture(fixDef);
        body.m_angularDamping = objAngularConst;
        body.m_linearDamping = objLinearConst;
        return body;
    }
    function init() {
        var test = localStorage.getItem("test"); //Creates object for localStorage
        if (test == null) { //Test if 'test' object already exists
            if (testRobots) { //If not, create test
                test = {
                    currentRun: 0,
                    test: {
                        runs: [35, 50, 100, 150], //Input values for each page refresh

                        outcomes: []
                    }
                }
            } else if (testNoise) { //Change brownian noise 0,.1,.5,1,5
                test = {
                    currentRun: 0,
                    test: {
                        runs: [300, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200],
                        outcomes: []
                    }
                }
            } else if (testObj) { //Tests object density
                test = {
                    currentRun: 0,
                    test: {
                        runs: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                        outcomes: []
                    }
                }
            }
            localStorage.setItem("test", JSON.stringify(test)); //Stores object 'test' into Local Storage
        }
        if (testing) {//Get values to run simulations
            var inputTest = JSON.parse(localStorage.getItem("test")); //Store Local Storage object into local object 
            var value = JSON.parse(inputTest.test.runs[inputTest.currentRun]); //Gets object properties
            if (testRobots) {
                var numrobots = value; //Set variable to input array runs[]
                var totalRobots = value;
            } else if (testNoise) {
                var numrobots = 100; //Get value for noise
                var totalRobots = 100;
            } else if (testObj) {
                var numrobots = 100; //Get value for object density
                var totalRobots = 100;
                objAngularConst = value;
                objLinearConst = objAngularConst;
            }
        } else {
            var numrobots = 100; //Counter for number of robots in regions
            var totalRobots = 100; //Total number of robots in simulation
        }
        //region Arrays
        var mainMaps = new Array();
        var transferMaps = new Array();
        ///////////////creating the main Regions
        mainMaps[0] = new Array(); //creating 3D array
        mainMaps[1] = new Array();
        mainMaps[2] = new Array();
        for (i = 0; i <= 20; i++) {
            mainMaps[0][i] = new Array();
            mainMaps[1][i] = new Array();
            mainMaps[2][i] = new Array();
        }
        for (i = 0; i <= 20; i++) { //setting the background to 0
            for (j = 0; j <= 20; j++) {
                mainMaps[0][i][j] = 0;
                mainMaps[1][i][j] = 0;
                mainMaps[2][i][j] = 0;
            }
        }
        //creating each mainRegion
        for (x = 1; x <= 20; x++) {
            for (y = 13; y <= 20; y++) {
                mainMaps[0][x][y] = 1;
            }
        }
        for (x = 1; x <= 20; x++) {
            for (y = 7; y < 13; y++) {
                mainMaps[1][x][y] = 1;
            }
        }
        for (x = 1; x <= 20; x++) {
            for (y = 1; y < 7; y++) {
                mainMaps[2][x][y] = 1;
            }
        }
        //creating the transfer Regions
        transferMaps[0] = new Array(); //creating 3D array
        transferMaps[1] = new Array();
        for (i = 0; i <= 20; i++) {
            transferMaps[0][i] = new Array();
            transferMaps[1][i] = new Array();
        }
        for (i = 0; i <= 20; i++) { //setting the background to 0
            for (j = 0; j <= 20; j++) {
                transferMaps[0][i][j] = 0;
                transferMaps[1][i][j] = 0;
            }
        }
        for (x = 15; x <= 20; x++) {
            for (y = 7; y <= 20; y++) {
                transferMaps[0][x][y] = 1;
            }
        }
        for (x = 1; x <= 4; x++) {
            for (y = 1; y < 13; y++) {
                transferMaps[1][x][y] = 1;
            }
        }
        //creating region status and control variables
        regionNum = 0;
        regionMain = true;
        var robotVar = false; //Flag for when number of robots reaches below the minimum limit
        var windowStopped = false;
        //variables for getting mean unstuck
        var prev_mean_position_x = 0; //previous mean positions of the block
        var prev_mean_position_y = 0;
        //Timers to check the mean's position every five seconds
        var start_timer = false; 
        var stop_timer = true;
        var timer = 0;
        var timer_var = false; //Flag when mean is stuck
        var robotVarTimer = false;
        var objMain = null; //Region object is in
        var corner = null;
        var mostRobotMainRegion = null; //Region with the most robots
        var secondMostRobotMainRegion = null;//Region with the second most robots
        //////////////////////
        var b2Vec2 = Box2D.Common.Math.b2Vec2
        , b2AABB = Box2D.Collision.b2AABB
        , b2BodyDef = Box2D.Dynamics.b2BodyDef
        , b2Body = Box2D.Dynamics.b2Body
        , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
        , b2Fixture = Box2D.Dynamics.b2Fixture
        , b2World = Box2D.Dynamics.b2World
        , b2MassData = Box2D.Collision.Shapes.b2MassData
        , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
        , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
        , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
        , b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
        ;
        var world = new b2World(
            new b2Vec2(0, 00) //gravity setting to zero removes gravity
            , true //allow sleep
            );
        var canvas = $('#canvas');
        var context = canvas.get(0).getContext('2d');
        var timeStart = null;
        var timeFinish = null;
        var timer = null;
        var passed = null;
        var overall_time = null;
        var firstloop = true;
        var boundaryHeight = 2;
        var boundaryWidth = 20;

        var fixDef = new b2FixtureDef;
        fixDef.density = 1.0;
        fixDef.friction = 0.5;
        fixDef.restitution = 0.25; //bouncing value
        var bodyDef = new b2BodyDef;

        //create enclosing boundary rectangles
        bodyDef.userData = 'obstacle';
        bodyDef.type = b2Body.b2_staticBody;
        fixDef.shape = new b2PolygonShape;
        fixDef.shape.SetAsBox(20, 2);//width, height
        bodyDef.position.Set(10, width / mapScale + 1); //bottom
        var bodyBottom = world.CreateBody(bodyDef);
        bodyBottom.CreateFixture(fixDef);
        bodyDef.position.Set(10, -1); //top
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        fixDef.shape.SetAsBox(2, 14);//width, height
        bodyDef.position.Set(-1, 13); //left
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        bodyDef.position.Set(21, 13); // right side
        world.CreateBody(bodyDef).CreateFixture(fixDef);

        // maze
        bodyDef.userData = 'maze';
        fixDef.shape.SetAsBox(10, 0.5);//width, height
        bodyDef.position.Set(15, width / 4 / mapScale + 1.5); //TOP
        var bodyBottom = world.CreateBody(bodyDef);
        bodyBottom.CreateFixture(fixDef);

        bodyDef.position.Set(5, width * 2 / 3 / mapScale + 0.2); //BOTTOM
        world.CreateBody(bodyDef).CreateFixture(fixDef);

        //create an object to move
        if (Hexagon) {
            makeHexagon(world, 7, 15.5);
            bodyDef.userData = 'moveable';
        } else if (Square) {
            bodyDef.type = b2Body.b2_dynamicBody;
            fixDef.density = 8.0;
            fixDef.friction = 0.3;
            fixDef.restitution = 0.2;  //bouncing value
            bodyDef.position.Set(7, 15.5);
            bodyDef.userData = 'moveable';
            fixDef.shape = new b2PolygonShape;
            fixDef.shape.SetAsBox(1.2, 1.2);
            var obst = world.CreateBody(bodyDef);
            obst.CreateFixture(fixDef);
            obst.m_angularDamping = objAngularConst;
            obst.m_linearDamping = objLinearConst;
        } else if (shortRect) {
            bodyDef.type = b2Body.b2_dynamicBody;
            fixDef.density = 8.0;
            fixDef.friction = 0.3;
            fixDef.restitution = 0.2;  //bouncing value
            bodyDef.position.Set(7, 15.5);
            bodyDef.userData = 'moveable';
            fixDef.shape = new b2PolygonShape;
            fixDef.shape.SetAsBox(.8, 1.5);
            var obst = world.CreateBody(bodyDef);
            obst.CreateFixture(fixDef);
            obst.m_angularDamping = objAngularConst;
            obst.m_linearDamping = objLinearConst;
        } else if (longRect) {
            bodyDef.type = b2Body.b2_dynamicBody;
            fixDef.density = 8.0;
            fixDef.friction = 0.3;
            fixDef.restitution = 0.2;  //bouncing value
            bodyDef.position.Set(7, 15.5);
            bodyDef.userData = 'moveable';
            fixDef.shape = new b2PolygonShape;
            fixDef.shape.SetAsBox(.8, 2.2);
            var obst = world.CreateBody(bodyDef);
            obst.CreateFixture(fixDef);
            obst.m_angularDamping = objAngularConst;
            obst.m_linearDamping = objLinearConst;
        } else if (Circle) {
            bodyDef.type = b2Body.b2_dynamicBody;
            fixDef.density = 8.0;
            fixDef.friction = 0.3;
            fixDef.restitution = 0.2;  //bouncing value
            bodyDef.userData = 'moveable';
            bodyDef.position.x = 7;
            bodyDef.position.y = 15.5;
            objectRad = 1.36;
            fixDef.shape = new b2CircleShape(objectRad);
            var obst = world.CreateBody(bodyDef);
            obst.CreateFixture(fixDef);
            obst.m_angularDamping = objAngularConst;
            obst.m_linearDamping = objLinearConst;
        }
        //create the robots
        bodyDef.type = b2Body.b2_dynamicBody;
        var robotrad = 0.15; //for SwarmControl.net, we used 0.2;

        var CornerValuesX = [1, 19, 19, 1, 1, 100]; //variance corners
        var CornerValuesY = [19, 19, 7, 13, 1, 100];
        var CornerValuesD = [51, 41, 30, 24, 17, 100];
        if (MDP_DebugMode || Gradient_DebugMode) {
            numrobots = 0;
        }
        fixDef.density = 10.0;
        fixDef.friction = 2;
        fixDef.restitution = .5; //bouncing value
        fixDef.isSensor = false;
        var m_Robot = new Array();
        var rowLength = Math.floor(5 / (2 * robotrad));
        fixDef.shape = new b2CircleShape(robotrad);

        for (var i = 0; i < numrobots; ++i) {
            bodyDef.userData = 'robot';
            bodyDef.position.x = 1.5 + (i % rowLength) * 2 * robotrad;
            bodyDef.position.y = 18.5 - Math.floor(i / rowLength) * 2 * robotrad;
            m_Robot[i] = world.CreateBody(bodyDef);
            m_Robot[i].CreateFixture(fixDef);
            m_Robot[i].m_angularDamping = 1; //was 1, we used 10 on SwarmControl
            m_Robot[i].m_linearDamping = 1;
        }
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (/* function */ callback, /* DOMElement */ element) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();
        ///////////////////////////////////
        var infinity = mapXSize * mapYSize;
        var mazeSize = 15;
        var mazeTopY = 13;
        var mazeDownY = 6;
        var goalPositionX = 16;
        var goalPositionY = 3;
        var goalPositionXDraw = 16.5;
        var goalPositionYDraw = 3.5;
        //giving -100 to boundaries

        if (ifBFS) {    //at the end, map[x][y] is the BFS distance to the goal
            for (var i = 0 ; i < mapXSize; i++) {
                map[i][0] = -1;
                map[i][mapYSize - 1] = -1;
                map[0][i] = -1;
                map[mapXSize - 1][i] = -1;
            }
            // giving -1 to obstacles.(Down Maze)
            for (var i = 0 ; i < mazeSize; i++) {
                map[i][mazeTopY] = -1;
            }
            //Top Maze
            for (var i = mapXSize - 1 ; i > mapXSize - mazeSize - 1 ; i--) {
                map[i][mazeDownY] = -1;
            }
            for (var i = 0 ; i < mapXSize ; i++) {
                for (var j = 0 ; j < mapYSize; j++) {
                    if (map[i][j] != -1) {
                        map[i][j] = infinity;
                    }
                }
            }
            map[goalPositionX][goalPositionY] = 0;
            BFS(goalPositionX, goalPositionY);
            ifBFS = false;
        }

        if (ifMDP) {
            for (var i = 0 ; i < mapXSize; i++) {
                map_MDP[i][0] = -100;
                map_MDP[i][mapYSize - 1] = -100;
                map_MDP[0][i] = -100;
                map_MDP[mapXSize - 1][i] = -100;

                map_R[i][0] = -50;
                map_R[i][mapYSize - 1] = -50;
                map_R[0][i] = -50;
                map_R[mapXSize - 1][i] = -50;

                map_prev[i][0] = 0;
                map_prev[i][mapYSize - 1] = 0;
                map_prev[0][i] = 0;
                map_prev[mapXSize - 1][i] = 0;

            }
            // giving -100 to obstacles.(Down Maze)
            for (var i = 0 ; i < mazeSize; i++) {
                map_MDP[i][mazeTopY] = -100;
                map_R[i][mazeTopY] = -50;
                map_prev[i][mazeTopY] = 0;
            }
            //Top Maze
            for (var i = mapXSize - 1 ; i > mapXSize - mazeSize - 1  ; i--) {
                map_MDP[i][mazeDownY] = -100;
                map_R[i][mazeDownY] = -50;
                map_prev[i][mazeDownY] = 0;
            }

            for (var i = 0 ; i < mapXSize ; i++) {
                for (var j = 0 ; j < mapYSize; j++) {
                    if (map_MDP[i][j] != -100) {
                        map_MDP[i][j] = -1;
                        map_R[i][j] = -1;
                        map_prev[i][j] = 0;
                    }
                }

            }
            map_MDP[goalPositionX][goalPositionY] = 100;
            map_R[goalPositionX][goalPositionY] = 100;

            while ((iteration < iteration_limit)) {
                map_prev = map_MDP;
                for (var i = 0; i < mapXSize; i++) {
                    for (var j = 0; j < mapYSize; j++) {
                        if (map_MDP[i][j] != -100) {
                            policy_MDP(i, j);
                            map_MDP[i][j] = gamma * (map_R[i][j] + bestpayoff);
                            policy_x[i][j] = -bestmove[0];
                            policy_y[i][j] = -bestmove[1];

                            policy_angle[i][j] = Math.atan2(policy_y[i][j], policy_x[i][j]) * 180 / Math.PI + 270;

                        }
                    }
                }
                iteration++;
            }
            ifMDP = false;
        }

        if (ifGradient) {   //for each cell, calculate the gradient
            for (var i = 0 ; i < mapXSize; i++) {
                for (var j = 0 ; j < mapYSize; j++) {
                    Gradient(i, j);
                }
            }
            ifGradient = false;
        }

        (function animloop() {
            requestAnimFrame(animloop);
            update();
        })();
        if (timeStart == null) {
            var day = new Date();
            timeStart = day.getTime();
        }
        function lineDistance(x1, y1, x2, y2) {
            var xs = 0;
            var ys = 0;
            xs = x1 - x2;
            xs = xs * xs;
            ys = y1 - y2;
            ys = ys * ys;
            return Math.sqrt(xs + ys);
        }

        var hasLoggedData = false; //Flag to show that result is stored in Local Storage
        function update() {
            var impulseV = new b2Vec2(0, 0);
            var impulse = 3.0;
            if (m_controlState & ROBOT_INPUT.ROBOT_PROP) {
                impulseV.x = m_ControlInputX;
                impulseV.y = m_ControlInputY;
            }
            //apply Brownian noise:
            var brownianImpulse = new b2Vec2(0, 0);
            var mag = 0;
            var ang = 0;
            var vary = 5; //was 5
            if (testing) {//getting values to run simulations
                var inputTest = JSON.parse(localStorage.getItem("test"));
                if (inputTest.currentRun >= inputTest.test.runs.length) {
                    window.stop();
                    console.log("window stopped");
                    windowStopped = true;
                } else {
                    var value = JSON.parse(inputTest.test.runs[inputTest.currentRun]);
                    if (testRobots) {
                        numrobots = value; //getting value for robots
                        totalRobots = value;
                    } else if (testNoise) {
                        vary = value; //getting value for brownian noise
                        numrobots = 100; //getting value for robots
                        totalRobots = 100;
                    }
                }
            }
            //Calculates the min/max variance limit based on vary
            var max_desired_var_x_constant = (.006) * vary + .45;
            var min_desired_var_x_constant = (max_desired_var_x_constant - (.005 * vary + .3));
            //Applies velocity to robots
            for (var i = 0; i < m_Robot.length; i++) {
                mag = vary * Math.random();
                ang = 2 * Math.PI * Math.random();
                brownianImpulse.x = mag * Math.cos(ang) + impulseV.x;
                brownianImpulse.y = mag * Math.sin(ang) + impulseV.y;
                m_Robot[i].ApplyForce(brownianImpulse, m_Robot[i].GetWorldPoint(new b2Vec2(0, 0)));
            }
            world.Step(1 / 60, 10, 10);
            world.DrawDebugData();
            world.ClearForces();
            $("canvas").clearCanvas();
            $("canvas").rotateCanvas(
            {
                x: 5 * mapScale, y: 5 * mapScale,
                rotate: angle
            }).drawArc(
            {
                fillStyle: "green",
                x: 5 * mapScale, y: 5 * mapScale,
                radius: radius * mapScale
            }).drawArc(
            {
                strokeStyle: "#39FF14",
                strokeWidth: 7, //fillStyle: "green",
                x: goalPositionXDraw * mapScale, y: goalPositionYDraw * mapScale,
                radius: 2.3 * mapScale
            }).drawText(
            {
                strokeStyle: "green",
                fillStyle: "green",
                strokeWidth: 2,
                x: goalPositionXDraw * mapScale, y: goalPositionYDraw * mapScale,
                fontSize: 30,
                fontFamily: 'Verdana, sans-serif',
                text: "Goal"
            }).restoreCanvas();

            if (MDP_DebugMode) {
                for (var i = 0 ; i < mapXSize; i++)
                    for (var j = 0 ; j < mapYSize; j++) {
                        if (map_MDP[i][j] != 100 && map_MDP[i][j] != 52) {
                            $("canvas").drawText(
                            {
                                strokeStyle: 'green',
                                strokeWidth: 2,
                                x: (i + 0.5) * mapScale, y: (j + 0.5) * mapScale,
                                fontSize: 20,
                                fontFamily: 'Verdana, sans-serif',
                                text: Math.round(map_MDP[i][j] / 10 - 36)
                            });
                        }
                        else if (map_MDP[i][j] == 100) {
                            $("canvas").drawText(
                            {
                                strokeStyle: "brown",
                                strokeWidth: 2,
                                x: (i + 0.5) * mapScale, y: (j + 0.5) * mapScale,
                                fontSize: 20,
                                fontFamily: 'Verdana, sans-serif',
                                text: map_MDP[i][j]
                            });
                        }
                    }
            }

            if (Gradient_DebugMode_MDP) {
                for (var i = 0 ; i < mapXSize; i++) {
                    for (var j = 0 ; j < mapYSize; j++) {
                        $('canvas').drawVector({
                            strokeStyle: '#000',
                            strokeWidth: 2,
                            rounded: true,
                            endArrow: true,
                            arrowRadius: 10,
                            arrowAngle: 30,
                            x: mapScale * (i + 0.5 + 0.5 * Math.cos((90 + policy_angle[i][j]) * Math.PI / 180.0)), y: mapScale * (j + 0.5 + 0.5 * Math.sin((90 + policy_angle[i][j]) * Math.PI / 180.0)),
                            a1: policy_angle[i][j], l1: mapScale
                        });
                    }
                }
            }

            if (BFSDebugMode) {
                for (var i = 0 ; i < mapXSize; i++)
                    for (var j = 0 ; j < mapYSize; j++) {
                        if (map[i][j] != 0 && map[i][j] != 52) {
                            $("canvas").drawText(
                            {
                                strokeStyle: '#25a',
                                strokeWidth: 2,
                                x: (i + 0.5) * mapScale, y: (j + 0.5) * mapScale,
                                fontSize: 20,
                                fontFamily: 'Verdana, sans-serif',
                                text: map[i][j]
                            });
                        }
                        else if (map[i][j] == 0) {
                            $("canvas").drawText(
                            {
                                strokeStyle: "yellow",
                                strokeWidth: 2,
                                x: (i + 0.5) * mapScale, y: (j + 0.5) * mapScale,
                                fontSize: 20,
                                fontFamily: 'Verdana, sans-serif',
                                text: map[i][j]
                            });
                        }
                        else if (map[i][j] == 52) {
                            $("canvas").drawText({
                                strokeStyle: "yellow",
                                strokeWidth: 2,
                                x: (i + 0.5) * mapScale, y: (j + 0.5) * mapScale,
                                fontSize: 20,
                                fontFamily: 'Verdana, sans-serif',
                                text: map[i][j]
                            });
                        }
                    }
            }
            if (Gradient_DebugMode) {
                for (var i = 0 ; i < mapXSize; i++) {
                    for (var j = 0 ; j < mapYSize; j++) {
                        $('canvas').drawVector({
                            strokeStyle: '#000',
                            strokeWidth: 2,
                            rounded: true,
                            endArrow: true,
                            arrowRadius: 10,
                            arrowAngle: 30,
                            x: mapScale * (i + 0.5 + 0.5 * Math.cos((90 + gradient_angle[i][j]) * Math.PI / 180.0)), y: mapScale * (j + 0.5 + 0.5 * Math.sin((90 + gradient_angle[i][j]) * Math.PI / 180.0)),
                            a1: gradient_angle[i][j], l1: mapScale
                        });
                    }
                }
            }
            //draw robots and obstacles
            function _drawRobot(x, y, angle, radius) {
                $("canvas").rotateCanvas(
                {
                    x: x * mapScale, y: y * mapScale,
                    rotate: angle
                })
                .drawArc(
                {
                    strokeStyle: "blue",
                    strokeWidth: 3,
                    fillStyle: "#39FF14",
                    x: x * mapScale, y: y * mapScale,
                    radius: radius * mapScale
                })
                .restoreCanvas();
            }
            //draw robots and obstacles
            for (b = world.GetBodyList() ; b; b = b.GetNext()) {
                var angle = b.GetAngle() * (180 / Math.PI);
                var userData = b.GetUserData();
                var pos = b.GetPosition();
                for (f = b.GetFixtureList() ; f; f = f.GetNext()) {
                    if (userData == 'robot') {
                        var radius = f.GetShape().GetRadius();
                        _drawRobot(pos.x, pos.y, angle, radius);
                    }
                    else if (userData == 'obstacle' || userData == 'moveable' || userData == 'rectangle_ground' || userData == 'maze') {
                        if (userData != 'moveable') {
                            var X = f.GetShape().GetVertices()[1].x - f.GetShape().GetVertices()[0].x;
                            var Y = f.GetShape().GetVertices()[2].y - f.GetShape().GetVertices()[1].y;
                        }
                        else if (!Circle) {
                            var X = f.GetShape().GetVertices()[1].x - f.GetShape().GetVertices()[0].x;
                            var Y = f.GetShape().GetVertices()[2].y - f.GetShape().GetVertices()[1].y;
                        }

                        if (userData == 'moveable') {
                            var color = 'black';
                            blockCOM_x = pos.x;
                            blockCOM_y = pos.y;

                            if (Hexagon) {
                                $("canvas")
                            .rotateCanvas({
                                x: pos.x * mapScale, y: pos.y * mapScale,
                                rotate: angle
                            })
                            .drawPolygon({
                                strokeStyle: 'black', //Black perimeter
                                strokeWidth: 8,
                                fillStyle: "#39FF14", //Inside color
                                x: pos.x * mapScale, y: pos.y * mapScale,
                                radius: 1.5 * mapScale,
                                sides: 6,
                                rotate: angle || 0
                            }).restoreCanvas();

                            }
                            else if (Square) {
                                $("canvas")
                              .rotateCanvas({
                                  x: pos.x * mapScale, y: pos.y * mapScale,
                                  rotate: angle
                              })
                             .drawRect({
                                 strokeStyle: 'black',
                                 strokeWidth: 8,
                                 fillStyle: "#39FF14",
                                 x: pos.x * mapScale, y: pos.y * mapScale,
                                 width: 2.4 * mapScale,
                                 height: 2.4 * mapScale,
                                 cornerRadius: 0
                             }).restoreCanvas();
                            }
                            else if (shortRect) {
                                $("canvas")
                              .rotateCanvas({
                                  x: pos.x * mapScale, y: pos.y * mapScale,
                                  rotate: angle
                              })
                             .drawRect({
                                 strokeStyle: 'black',
                                 strokeWidth: 8,
                                 fillStyle: "#39FF14",
                                 x: pos.x * mapScale, y: pos.y * mapScale,
                                 width: X * mapScale * .95,
                                 height: Y * mapScale * .95,
                                 cornerRadius: 0
                             }).restoreCanvas();
                            }
                            else if (longRect) {
                                $("canvas")
                              .rotateCanvas({
                                  x: pos.x * mapScale, y: pos.y * mapScale,
                                  rotate: angle
                              })
                             .drawRect({
                                 strokeStyle: 'black',
                                 strokeWidth: 8,
                                 fillStyle: "#39FF14",
                                 x: pos.x * mapScale, y: pos.y * mapScale,
                                 width: X * mapScale * .95,
                                 height: Y * mapScale * .95,
                                 cornerRadius: 0
                             }).restoreCanvas();
                            }
                            else if (Circle) {
                                var objRad = f.GetShape().GetRadius();

                                $("canvas")
                              .rotateCanvas({
                                  x: pos.x * mapScale, y: pos.y * mapScale,
                                  rotate: angle
                              })
                              .drawArc({
                                  strokeStyle: 'black',
                                  strokeWidth: 8,
                                  fillStyle: "#39FF14",
                                  x: pos.x * mapScale, y: pos.y * mapScale,
                                  radius: 1.36 * mapScale
                              }).restoreCanvas();
                            }
                            continue;


                        } else if (userData == 'rectangle_ground') {
                            var color = 'green';
                        } else if (userData == 'maze') {
                            var color = 'brown';
                        } else if (userData == 'obstacle') {
                            var color = 'brown';
                        }

                        $("canvas").rotateCanvas({
                            x: pos.x * mapScale, y: pos.y * mapScale,
                            rotate: angle
                        })
                        .drawRect({
                            fillStyle: color,
                            x: pos.x * mapScale, y: pos.y * mapScale,
                            width: X * mapScale,
                            height: Y * mapScale,
                            cornerRadius: 0
                        })
                        .restoreCanvas();

                        if (MDP_DebugMode || Gradient_DebugMode_MDP) {
                            for (var i = 0 ; i < 20; i++) {
                                break;
                                $("canvas").drawLine(
                                {
                                    strokeStyle: 'gray',
                                    strokeWidth: 1,
                                    x1: i * mapScale, y1: 0,
                                    x2: i * mapScale, y2: 20 * mapScale
                                })
                                .drawLine({
                                    strokeStyle: 'gray',
                                    strokeWidth: 1,
                                    x1: 0, y1: i * mapScale,
                                    x2: 20 * mapScale, y2: i * mapScale
                                })
                            }
                            $("canvas").restoreCanvas();
                        }
                    }
                }
            }

            if (!goalRecieved) {
                $("canvas")
                .drawArc({
                    //draw the goal mean position
                    strokeStyle: "lightblue",
                    strokeWidth: 5,
                    x: goalX * mapScale, y: goalY * mapScale,
                    radius: radius * mapScale
                }).drawArc({
                    //draw the goal mean position
                    strokeStyle: "lightblue",
                    strokeWidth: 5,
                    x: goalX * mapScale, y: goalY * mapScale,
                    radius: (radius + 0.2) * mapScale
                }).restoreCanvas();
            }
            $("canvas").drawArc({
                //COM of the block
                strokeStyle: "orange",
                strokeWidth: 5,
                x: blockCOM_x * mapScale, y: blockCOM_y * mapScale,
                radius: radius * mapScale
            })
            .restoreCanvas();

            var day = new Date();
            if (timeFinish == null && false)
            { timeFinish = day.getTime(); }
            if (overall_time == null) // set the start time
            {
                overall_time = day.getTime();
                goalStartTime = day.getTime();
            }
            var elapsedTimeSec = (day.getTime() - overall_time) / 1000;

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // CONTROLLER
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            //goal positions
            var cycleInSec = 20;
            var amplitudeY = 5;
            var offsetY = 5;
            var amplitudeX = 5;
            var offsetX = 5;

            var sum_position_x = 0;
            var sum_position_y = 0;
            var sum2_x = 0;
            var sum2_y = 0;
            var desired_var_x;
            var cov_xy = 0;
            var block_x = Math.floor(blockCOM_x);
            var block_y = Math.floor(blockCOM_y);
            if (isNaN(block_y)) {
                var state = JSON.parse(localStorage.getItem("test"));
                console.log()
                hasLoggedData = true;
                state.test.outcomes[state.currentRun] = state.currentRun + " NaN";
                state.currentRun++;
                localStorage.setItem("test", JSON.stringify(state));
            }
            //Toggles state machine and switches regions
            if (regionMain) {
                var blockPosition = mainMaps[regionNum][block_x][block_y];
            }
            if (!regionMain) {
                var blockPosition = transferMaps[regionNum][block_x][block_y];
            }
            if (blockPosition == 0) {
                if (regionMain) {//if it's in the main region
                    regionMain = false; //switch to transfer regions
                    if (transferMaps[0][block_x][block_y] == 1) {
                        regionNum = 0; //checking which region the block is in
                    }
                    else if (transferMaps[1][block_x][block_y] == 1) {
                        regionNum = 1;
                    }
                } else if (!regionMain) {
                    regionMain = true;
                    if (mainMaps[0][block_x][block_y] == 1) {
                        regionNum = 0;
                    } else if (mainMaps[1][block_x][block_y] == 1) {
                        regionNum = 1;
                    } else if (mainMaps[2][block_x][block_y] == 1) {
                        regionNum = 2;
                    }
                }
            }
            var regionRobotCount = 0; //Number of robots in current region
            //Get sum of all robots in region
            if (regionMain) {
                for (var i = 0; i < totalRobots; ++i) {
                    var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                    var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                    var pos = mainMaps[regionNum][pos_x][pos_y];
                    if (pos == 1) {
                        sum_position_x += m_Robot[i].GetPosition().x;
                        sum_position_y += m_Robot[i].GetPosition().y;
                        regionRobotCount = regionRobotCount + 1;
                    }
                }
            }
            if (!regionMain) {
                for (var i = 0; i < totalRobots; ++i) {
                    var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                    var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                    var pos = transferMaps[regionNum][pos_x][pos_y];
                    if (pos == 1) {
                        sum_position_x += m_Robot[i].GetPosition().x;
                        sum_position_y += m_Robot[i].GetPosition().y;
                        regionRobotCount = regionRobotCount + 1;
                    }
                }
            }
            numrobots = regionRobotCount;
            //Mean calculation
            var mean_position_x = sum_position_x / numrobots;
            var mean_position_y = sum_position_y / numrobots;
            //Covariance calculation for robots in region
            if (regionMain) {
                for (var i = 0; i < numrobots; ++i) {
                    var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                    var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                    var pos = mainMaps[regionNum][pos_x][pos_y];
                    if (pos == 1) {
                        sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
                        sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
                        cov_xy = cov_xy + (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().y - mean_position_y) / numrobots;
                    }
                }
            }
            if (!regionMain) {
                for (var i = 0; i < numrobots; ++i) {
                    var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                    var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                    var pos = transferMaps[regionNum][pos_x][pos_y];
                    if (pos == 1) {
                        sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
                        sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
                        cov_xy = cov_xy + (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().y - mean_position_y) / numrobots;
                    }
                }
            }
            //Calculate variance control min/max
            max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
            min_desired_var_x = numrobots * robotrad * min_desired_var_x_constant; //was .663
            max_desired_var_y = max_desired_var_x;
            min_desired_var_y = min_desired_var_x;

            var var_x = sum2_x / numrobots;
            var var_y = sum2_y / numrobots;
            var diffeq = Math.sqrt((var_x - var_y) * (var_x - var_y) / 4 + cov_xy * cov_xy);
            var var_xp = (var_x + var_y) / 2 + diffeq;
            var var_yp = (var_x + var_y) / 2 - diffeq;
            var angle2 = 180 / Math.PI * 1 / 2 * Math.atan2(2 * cov_xy, var_x - var_y);
            var angle_min_variance = 180 / Math.PI * 1 / 2 * Math.atan2(2 * cov_xy, min_desired_var_x - min_desired_var_y);
            var angle_max_variance = 180 / Math.PI * 1 / 2 * Math.atan2(2 * cov_xy, max_desired_var_x - max_desired_var_y);
            var index_x = Math.floor(mean_position_x);
            var index_y = Math.floor(mean_position_y);

            //Controller for when number of robots in current region reaches below minimum limit
            minRobotCount = totalRobots / 2; //Minimum robots in region
            if ((regionRobotCount < minRobotCount)) {
                robotVar = true; //Flag is true when number of robots in current region reaches below minimum limit
            } else {
                robotVar = false;
                robotVarTimer = false;
            }
            /*When robotVar=true, loops once and robotVarTimer sets this as a goal for five seconds.
            robotVarTimer solves the bouncing back and forth issue.
            Calculate appropriate corner to regroup.*/
            if (robotVar && !robotVarTimer) {
                //Counts robots in each region
                robotVarTimer = true;
                var countMain0 = 0;
                var countMain1 = 0;
                var countMain2 = 0;
                for (i = 0; i < totalRobots; i++) {
                    var pos_x = Math.floor(m_Robot[i].GetPosition().x);
                    var pos_y = Math.floor(m_Robot[i].GetPosition().y);
                    var pos0 = mainMaps[0][pos_x][pos_y];
                    var pos1 = mainMaps[1][pos_x][pos_y];
                    var pos2 = mainMaps[2][pos_x][pos_y];
                    if (pos0 == 1) {
                        countMain0++;
                    } else if (pos1 == 1) {
                        countMain1++;
                    } else if (pos2 == 1) {
                        countMain2++;
                    }
                }
                //Finds the main regions with the most and second most robots
                if ((countMain0 >= countMain1) && (countMain0 >= countMain2)) {
                    mostRobotMainRegion = 0;
                    if (countMain1 >= countMain2) {
                        secondMostRobotMainRegion = 1;
                    } else secondMostRobotMainRegion = 2;
                }
                else if ((countMain1 >= countMain0) && (countMain1 >= countMain2)) {
                    mostRobotMainRegion = 1;
                    if (countMain0 > countMain2) {
                        secondMostRobotMainRegion = 0;
                    } else secondMostRobotMainRegion = 2;
                }
                else if ((countMain2 >= countMain0) && (countMain2 > countMain1)) {
                    mostRobotMainRegion = 2;
                    if (countMain0 > countMain1) {
                        secondMostRobotMainRegion = 0;
                    } else secondMostRobotMainRegion = 1;
                }
                //finding which main region the block is in
                var objPos0 = mainMaps[0][Math.floor(blockCOM_x)][Math.floor(blockCOM_y)];
                var objPos1 = mainMaps[1][Math.floor(blockCOM_x)][Math.floor(blockCOM_y)];
                var objPos2 = mainMaps[2][Math.floor(blockCOM_x)][Math.floor(blockCOM_y)];
                if (objPos0 == 1) { objMain = 0; }
                else if (objPos1 == 1) { objMain = 1; }
                else { objMain = 2; }
            }
            /*Checks this every time and goes to appropriate corner 
            finding the right var corner*/
            if (robotVar) {
                if (objMain == 0) {
                    corner = 1;
                } else if (objMain == 1) {
                    if (((mostRobotMainRegion == 0) || (secondMostRobotMainRegion == 0)) && ((mostRobotMainRegion == 1) || (secondMostRobotMainRegion == 1))) {
                        corner = 2;
                    } else if (((mostRobotMainRegion == 1) || (secondMostRobotMainRegion == 1)) && ((mostRobotMainRegion == 2) || (secondMostRobotMainRegion == 2)))
                        corner = 3;
                } else corner = 4;
                IndexMinDist = corner;
                goalX = mean_position_x + Math.cos(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));
                goalY = mean_position_y + Math.sin(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));
            }

            //Checks if mean has been stuck for five seconds
            //Timers
            if (stop_timer) {
                timer = 0;
                start_timer = true; //starts timer
                stop_timer = false;
                robotVarTime = false;
            }
            if (start_timer) {
                timer = elapsedTimeSec; //gets starting point
                prev_mean_position_x = mean_position_x; //get previous pos
                prev_mean_position_y = mean_position_y;
                start_timer = false;
            }
            if ((elapsedTimeSec - timer) > 5) {//Timer to get mean position every five seconds
                var mean_difference_x = Math.abs(prev_mean_position_x - mean_position_x);
                var mean_difference_y = Math.abs(prev_mean_position_y - mean_position_y);
                var mean_difference = lineDistance(mean_difference_x, mean_difference_y, 0, 0);

                timer_var = false;
                if (mean_difference < .1) { //The change in distance between mean positions five seconds apart
                    flagVar = true;
                    timer_var = true;
                    stop_timer = true;
                } else {
                    stop_timer = true; //stops timer
                    flagVar = false;
                }
            }
            ////////////////////////////////
            if (!goalRecieved) {
                $("canvas").drawEllipse({
                    strokeStyle: "red",
                    strokeWidth: 5,
                    setLineDash: 6,
                    x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                    width: 3 * 30 * Math.sqrt(var_xp), height: 3 * 30 * Math.sqrt(var_yp),
                    rotate: angle2
                })
                .restoreCanvas();
            } else {
                var winstring = "Success,\n " + totalRobots + " robots in " + Math.floor(timeFinished) + "s";
                goalRecieved = true;
                $("canvas").drawText(
                {
                    strokeStyle: "blue",
                    strokeWidth: 4,
                    x: 9 * mapScale, y: 10 * mapScale,
                    fontSize: 40,
                    fontFamily: 'Verdana, sans-serif',
                    text: winstring
                }).restoreCanvas();
            }
            if (Math.abs(blockCOM_x - goalPositionX) < 2 && Math.abs(blockCOM_y - goalPositionY) < 2) {
                goalRecieved = true;

                if (wroteFinish == false) {
                    timeFinished = elapsedTimeSec;
                    wroteFinish = true;
                }
                m_controlState = ROBOT_INPUT.ROBOT_IDLE;
            }
            var block_difference = lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y);

            if (!goalRecieved) {
                
                if (timer_var && (block_difference < 4) && (!robotVar)) {
                    //If mean is stuck, a small desired variance ensures variance control
                    min_desired_var_x = .1;
                    min_desired_var_y = min_desired_var_x;
                } else if (!robotVar) {
                    max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
                    min_desired_var_x = numrobots * robotrad * min_desired_var_x_constant; //was .663
                    max_desired_var_y = max_desired_var_x;
                    min_desired_var_y = min_desired_var_x;
                }

                if (var_x < min_desired_var_x && var_y < min_desired_var_y) {
                    flagVar = false;
                }
                if (var_x > max_desired_var_x || var_y > max_desired_var_y) {
                    flagVar = true;
                }
                //If in variance control and not robot variance control
                if (flagVar && !robotVar) {
                    if (!timer_var) {
                        if (regionMain)//if the object is in a main region
                        {
                            if (regionNum == 0) {
                                IndexMinDist = 0;
                            } else if (regionNum == 1) {
                                IndexMinDist = 2;
                            } else {
                                IndexMinDist = 4;
                            }
                        }
                        else //if the object is in a transfer region
                        {
                            if (regionNum == 0) {
                                IndexMinDist = 1;
                            } else {
                                IndexMinDist = 3;
                            }
                        }
                    } else {
                        if (regionMain)//if the object is in a main region
                        {
                            if (regionNum == 0) {
                                IndexMinDist = 1;
                            } else if (regionNum == 1) {
                                IndexMinDist = 3;
                            } else {
                                IndexMinDist = 5;
                            }
                        }
                        else //if the object is in a transfer region
                        {
                            if (regionNum == 0) {
                                IndexMinDist = 2;
                            } else {
                                IndexMinDist = 4;
                            }
                        }
                    }
                    goalX = mean_position_x + Math.cos(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));
                    goalY = mean_position_y + Math.sin(Math.atan2(CornerValuesY[IndexMinDist] - mean_position_y, CornerValuesX[IndexMinDist] - mean_position_x));

                }
                 //Potential Fields
                if (!flagVar && !robotVar) {
                    var r = 0.8;
                    alphaWant = Math.atan2(policy_y[block_x][block_y], policy_x[block_x][block_y]);

                    attPointX = blockCOM_x - r * Math.cos(alphaWant + Math.PI);
                    attPointY = blockCOM_y - r * Math.sin(alphaWant + Math.PI);
                    repPointX = blockCOM_x;
                    repPointY = blockCOM_y;
                    if (1000 < day.getTime() - goalStartTime || firstloop) {
                        rho = lineDistance(mean_position_x, mean_position_y, repPointX, repPointY);

                        inside = inside + 1;

                        theta = Math.atan2(mean_position_y - repPointY, mean_position_x - repPointX);
                        angdiff = alphaWant - theta;
                        if (angdiff > Math.PI) { angdiff = angdiff - 2 * Math.PI };
                        if (angdiff < -Math.PI) { angdiff = angdiff + 2 * Math.PI };
                        var CGoal = 1;

                        if ((rho < rhoNot && Math.abs(angdiff) > (goalAngle)) && !robotVar) {
                            FrepX = eta * ((1 / rho) - (1 / rhoNot)) * (1 / rho) * (1 / rho) * (repPointX - mean_position_x);//change these lines
                            FrepY = eta * ((1 / rho) - (1 / rhoNot)) * (1 / rho) * (1 / rho) * (repPointY - mean_position_y);
                            rho = lineDistance(mean_position_x, mean_position_y, attPointX, attPointY);
                            FattX = zeta * (mean_position_x - attPointX) / rho;//change these lines
                            FattY = zeta * (mean_position_y - attPointY) / rho;
                            distX = -CGoal * Math.cos(Math.atan2(FattY + FrepY, FattX + FrepX));
                            distY = -CGoal * Math.sin(Math.atan2(FattY + FrepY, FattX + FrepX));
                            max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
                            max_desired_var_y = max_desired_var_x;
                        } else if (!robotVar) {
                            var COMdist2swarm = lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y);
                            if (COMdist2swarm < 1.5) {
                                var r = 0.1;
                            } else var r = 0.8;
                            distX = CGoal * Math.cos(Math.atan2(blockCOM_y + r * policy_y[block_x][block_y] - mean_position_y, blockCOM_x + r * policy_x[block_x][block_y] - mean_position_x));
                            distY = CGoal * Math.sin(Math.atan2(blockCOM_y + r * policy_y[block_x][block_y] - mean_position_y, blockCOM_x + r * policy_x[block_x][block_y] - mean_position_x));
                            max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
                            max_desired_var_y = max_desired_var_x;
                        }
                        goalStartTime = day.getTime();
                    }
                    goalX = mean_position_x + distX;
                    goalY = mean_position_y + distY;
                }

                string = "Time = " + elapsedTimeSec + "s<br>inside # " + inside;
                $('#cc').html(string); //USERDATA WILL SHOWN IN "div" WITH ID "cc"

                $("canvas").drawArc({ //draw the average position
                    strokeStyle: "red",
                    strokeWidth: 5,
                    x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                    radius: radius * mapScale
                }).restoreCanvas();
                // .drawEllipse({
                //     strokeStyle: "green",
                //     strokeWidth: 5,
                //     setLineDash: 6,
                //     x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                //     width: 3 * 30 * Math.sqrt(min_desired_var_x), height: 3 * 30 * Math.sqrt(min_desired_var_y),
                //     rotate: angle2
                // })
                // .drawEllipse({
                //     strokeStyle: "green",
                //     strokeWidth: 5,
                //     setLineDash: 6,
                //     x: mean_position_x * mapScale, y: mean_position_y * mapScale,
                //     width: 3 * 30 * Math.sqrt(max_desired_var_x), height: 3 * 30 * Math.sqrt(max_desired_var_y),
                //     rotate: angle2
                // }).restoreCanvas();
                var Kgain = 10; //faster=bigger
                var Kderivative = 1; //smaller=faster
                var sum_velocity_x = 0;
                var sum_velocity_y = 0;
                for (var i = 0; i < numrobots; ++i) {
                    sum_velocity_x += m_Robot[i].GetLinearVelocity().x;
                    sum_velocity_y += m_Robot[i].GetLinearVelocity().y;
                }
                var mean_velocity_x = sum_velocity_x / numrobots;
                var mean_velocity_y = sum_velocity_y / numrobots;
                m_ControlInputY = Kgain * (goalY - mean_position_y) + Kderivative * (0 - mean_velocity_y);
                m_ControlInputX = Kgain * (goalX - mean_position_x) + Kderivative * (0 - mean_velocity_x);
                m_controlState = ROBOT_INPUT.ROBOT_PROP;
            }
            //Saves results in Local Storage
            if (goalRecieved && !hasLoggedData && testing) { 
                var state = JSON.parse(localStorage.getItem("test")); //Saves Local Storage object
                state.test.outcomes[state.currentRun] = elapsedTimeSec; //Stores results
                hasLoggedData = true;
                location.reload(true); //Reloads page for a new simulation
                state.currentRun++; //Increments input array runs:[]
                localStorage.setItem("test", JSON.stringify(state)); //Puts the adjusted objected back into Local Storage
            } else if ((elapsedTimeSec > 1000) && testing) { //Records run time error
                var state = JSON.parse(localStorage.getItem("test"));
                state.test.outcomes[state.currentRun] = state.test.runs[state.currentRun] + " run time error";
                hasLoggedData = true;
                location.reload(true);
                state.currentRun++;
                localStorage.setItem("test", JSON.stringify(state));
            }
            
            if (firstloop) { firstloop = false; }
        }; //end update
    };
</script>
<style>
    #cc {
        top: 600px;
        width: 600px;
        height: 200px;
        margin: 0;
        overflow: auto;
    }
</style>
</html>
