<!--
// IDEA:
try a biger obstacle shaped like hexagon, so we can push deepeer into the object?  Try a bigger world?
try a hysteresis based on time (go to corner for 5 seconds, then push.   If pushing for more than 5 seconds && variance> max variance, go to corner.)


// TODO: (remove items when completed)
//
//4. make controllers, drawing and bfs sections.
//
////////////////////////////////////////////////////////////description//
// We want to control variance and mean position and find a way to the goal.
/////////////////////////////////////////////////////////////////////////
//
// Author: Shiva Shahrocki and Aaron T. Becker
// Started" 11/01/2014 -- present
// Description: controls the mean position of n holonomic disk robots using mean position as feedback
/// uses a PD controller.
//
// Records output into a log file/
//
// Status {working, broken, in progress, replacedby}: broken: controller works, but log files are not yet working
//
///////////////////////////////////////////////////////////////////////////////
-->
<html>
<head>
    <title>Stochastic Swarm Control: Box Pushing</title>
</head>
<body onload="init();">
    <canvas id="canvas" width="800" height="800" style="background-color:#EEEEEE;"></canvas>
    <div id="cc"></div>
</body>
<script type="text/javascript" src="../shared/Box2dWeb-2.1.a.3.min.js"></script> <!-- box2d -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script> <!-- forms & strings -->
<script type="text/javascript" src="../shared/jcanvas.min.js"></script>
<script type="text/javascript">
// in Chrome, to view the console: Use the keyboard shortcut Command - Option - J (Mac) or Control -Shift -J (Windows/Linux).

///////////////////////////////
//Begin Global Variables
///////////////////////////////
var ROBOT_INPUT = {
	ROBOT_IDLE : 0x0,
	ROBOT_PROP : 0x01, //proportional control
	WAIT : 0x40
};

var width = 800;
var m_ControlInputY = 0;
var mapXSize = 20;
var mapYSize = 20;
var mapScale = 40;
var goalX = 5;
var goalY = 18;
var distX = 5;
var distY = 18;
var m_controlState = ROBOT_INPUT.ROBOT_IDLE;

var blockCOM_x = 0;
var blockCOM_y = 0;

// checking variables.
var flagVar = false;
var ifMDP = true;
var ifGradient = false;
var ifBFS = true;

// Debugging Variables.
var MDP_DebugMode = false;
var BFSDebugMode = false;
var Gradient_DebugMode = false;
var Gradient_DebugMode_MDP = false;
var goalRecieved = false;  //have we reached the goal?
var timeFinished = 1000;
var wroteFinish = false;

var map = new Array(mapXSize);
var map_MDP = new Array(mapXSize);
var map_R = new Array(mapXSize);
var map_prev = new Array(mapXSize);
var gradient_x = new Array(mapXSize);
var gradient_y = new Array(mapXSize);
var gradient_angle = new Array(mapXSize);
var policy_x = new Array(mapXSize);
var policy_y = new Array(mapXSize);
var policy_angle = new Array(mapXSize);

var bestpayoff = -200;
var payoff;
var gamma = 0.97;
var iteration = 0;
var iteration_limit = 200;
var probStraight = 0.5;

var move_ysize = 9;
var move_xsize = 2;
var moves = new Array(move_ysize);
var bestmove;
var move;

moves[0] = [1, 0];
moves[1] = [1, 1];
moves[2] = [0, 1];
moves[3] = [-1, 1];
moves[4] = [-1, 0];
moves[5] = [-1, -1];
moves[6] = [0, -1];
moves[7] = [1, -1];
moves[8] = [0, 0];

var zeta = 5;//attractive
var eta = 50;//repulsive
var rhoNot = 3; //radius for flow around was 3
var rho = 0;
var alphaWant = 0;
var inside = 0;
var goalStartTime = null;

var goalAngle = 2/8*Math.PI;

var k = [0, 2, 4, 6, 1, 3, 5, 7, 8];

for (var i = 0; i < mapXSize; i++)
{   // mapping data arrays
	map[i] = new Array(mapYSize);
	map_MDP[i] = new Array(mapYSize);
	map_R[i] = new Array(mapYSize);
	map_prev[i] = new Array(mapYSize);
	gradient_x[i] = new Array(mapYSize);
	gradient_y[i] = new Array(mapYSize);
	gradient_angle[i] = new Array(mapYSize);
	policy_x[i] = new Array(mapYSize);
	policy_y[i] = new Array(mapYSize);
	policy_angle[i] = new Array(mapYSize);
}

/////////////////////////////
//End Global Variables
/////////////////////////////

/////////////////////////////
//Begin Algorithmic Functions
/////////////////////////////


//.....policy_MDP...//


function BFS(x, y )
{  //recursively compute Breadth First Search from goal to every other grid cell
	var dist = map[x][y];
	if(dist == -1 ) // this is an obstacle region
		{return;}
	if(x-1 >0)
	{
		if(map[x-1][y] > dist +1)
		{
			map[x-1][y] = dist+1;
			BFS(x-1, y);
		}
	}
	if(y+1 < mapYSize)
	{
		if(map[x][y+1] > dist +1)
		{
			map[x][y+1] = dist+1;
			BFS(x, y+1);
		}
	}
	if(y-1 >0)
	{
		if(map[x][y-1] > dist +1)
		{
			map[x][y-1] = dist+1;
			BFS(x, y-1);
		}
	}
	if(x+1 < mapXSize)
	{
		if(map[x+1][y] > dist +1)
		{
			map[x+1][y] = dist+1;
			BFS(x+1, y);
		}
	}
}



function Gradient(x,y)
{  // computes the x and y gradient of cell(x,y)  requires a map with distance values.
	var dist = map[x][y];
	if(dist == -1)
	{
		gradient_x[x][y] = 0;
		gradient_y[x][y] = 0;
		return;
	}

	if(map[x-1][y] == -1 && map[x+1][y] == -1)
	{
		gradient_x[x][y] = 0;
	}
	else if(map[x-1][y] == -1 )
	{
		gradient_x[x][y]= map[x+1][y] - map[x][y];
	}
	else if(map[x+1][y] == -1 )
	{
		gradient_x[x][y]= map[x][y] - map[x-1][y];
	}
	else
	{
		gradient_x[x][y] = (map[x+1][y] - map[x-1][y])/2;
	}
	if(map[x][y-1] == -1 && map[x][y+1] == -1)
	{
		gradient_y[x][y] = 0;
	}
	else if(map[x][y-1] == -1 )
	{
		gradient_y[x][y]= 0;//map[x][y+1] - map[x][y];
	}
	else if(map[x][y+1] == -1 )
	{
		gradient_y[x][y]= map[x][y] - map[x][y-1];
	}
	else
	{
		gradient_y[x][y] = (map[x][y+1] - map[x][y-1])/2;
	}

		gradient_angle[x][y] = Math.atan2(gradient_y[x][y],gradient_x[x][y] ) * 180 / Math.PI + 270;
}

//to determine the gradient for Markov Decision Process

function policy_MDP(x, y)
{
	var moveR, moveL;
	bestpayoff = -200;
for (i = 0; i < k.length; i++ )
	{
		var kval=k[i];
		move = moves[kval];
		if(kval < 7)
			moveR = moves[kval+1];
		else
			moveR = moves[0];
		if(kval > 0)
			moveL = moves[kval-1];
		else
			moveL = moves[7];
		if(move == [0, 0])
		{
			moveR = [0, 0];
			moveL = [0, 0];
		}

		payoff = probStraight * (map_MDP[x + move[0]][y + move[1]]) +  ((1 - probStraight)/2) * (map_MDP[x + moveR[0]][y + moveR[1]]) + ((1 - probStraight)/2) * (map_MDP[x + moveL[0]][y + moveL[1]]);
		//alert(payoff);*/

		if (payoff > bestpayoff)
		{
			bestpayoff = payoff;
			bestmove = move;
		}
	}
}

////////////////////////////
//End Algorithmic Functions
////////////////////////////

///////////////////////////
//Begin Drawing Functions
///////////////////////////

function calcPointsCirc( cx,cy, rad, dashLength)
{	//draw a dashed circle
	var n = rad/dashLength,
	alpha = Math.PI * 2 / n,
	pointObj = {},
	points = [],
	i = -1;
	while( i < n )
	{
		var theta = alpha * i,
		theta2 = alpha * (i+1);
		points.push({x : (Math.cos(theta) * rad) + cx, y : (Math.sin(theta) * rad) + cy, ex : (Math.cos(theta2) * rad) + cx, ey : (Math.sin(theta2) * rad) + cy});
		i+=2;
	}
	return points;
}

//region Arrays
var mainMaps = new Array();
var transferMaps = new Array();
    //controls for simulation tests
var testing = true;
var testRobots = true;
var testNoise = false;
var TestShapes = false;

var regionNum = null; //to calculates object's region
var regionMain = null;
var mostRobotRegion = null; //for adjacent regionsf
var robotMain = null; //what map are the most robots in?
var robotCornerCount = null;
var DrawForce_DebugMode = true;

var max_desired_var_x = null;//numrobots * robotrad * max_desired_var_x_constant; //was 1.91
var min_desired_var_x = null; //was .663
var max_desired_var_y = max_desired_var_x;
var min_desired_var_y = min_desired_var_x;
var max_desired_var_x_constant = .55;
var min_desired_var_x_constant = .3;
    //determines variance corner based on regions
function findRegionBasedVar(regionMain, objRegion, robotMain, mostRobotRegion) {
    var corner;
    if (regionMain) { //if object is in a main region
        if(robotMain){ //if most of the robots are in a main region
            if (objRegion == 0) {
                corner=0;
            } else if (objRegion == 1) {
                corner=2;
            } else if (objRegion == 2) {
                corner=4;
            }
        }else{//if most of the robots are in the adj obj region map
            if (objRegion == 0) {
                corner = 0;
            } else if (objRegion == 1) {
                if (mostRobotRegion == 0) {
                    corner = 2;
                } else if (mostRobotRegion == 1) {
                    corner = 3;
                }
            } else if (objRegion == 2) {
                corner = 4;
            }
        }
    } else if (!regionMain) {
        if(!robotMain){ //if the most robots are in the same transfer region
            if (objRegion == 0) {
                corner=2;
            } else if (objRegion == 1) {
                corner=4;
            }
        }else{
            if (objRegion == 0) {
                if (mostRobotRegion == 0) {
                    corner = 1;
                } else if (mostRobotRegion == 1) {
                    corner = 2;
                }
            } else if (objRegion == 1) {
                if (mostRobotRegion == 1) {
                    corner = 3;
                } else if (mostRobotRegion == 2) {
                    corner = 4;
                }
            }
        }
    }
    return corner;
}

//hardcodes adjacent regions to each region
function findAdjRegion(regionMain, regionNum, x) {
    var adjRegions = new Array(2);
    if (regionMain) {
        if (regionNum == 0) {
            adjRegions[0] = 0; //adjacent region = transferRegion1
            adjRegions[1] = null;
        }
        else if (regionNum == 1) {
            adjRegions[0] = 0;
            adjRegions[1] = 1;
        } else if (regionNum == 2) {
            adjRegions[0] = 1;
            adjRegions[1] = null;
        }
    }
    if (!regionMain) {
        if (regionNum == 0) {
            adjRegions[0] = 0; //adjacent region = mainRegion1&2
            adjRegions[1] = 1;
        }
        else if (regionNum == 1) {
            adjRegions[0] = 1;
            adjRegions[1] = 2;
        }
    }
    if (x == 0) {
        return adjRegions[0];
    } else if (x == 1) {
        return adjRegions[1];
    }

}
///////////////////////////
//End Drawing Functions
///////////////////////////


    //vec2: Box2D.Common.Math.b2Vec2,
    //    AABB: Box2D.Collision.b2AABB,
    //bodyDef: Box2D.Dynamics.b2BodyDef,
    //body: Box2D.Dynamics.b2Body,
    //fixtureDef: Box2D.Dynamics.b2FixtureDef,
    //world: Box2D.Dynamics.b2World,
    //massData: Box2D.Collision.Shapes.b2MassData,
    //polyShape: Box2D.Collision.Shapes.b2PolygonShape,
    //circleShape: Box2D.Collision.Shapes.b2CircleShape,
    //mouseJointDef: Box2D.Dynamics.Joints.b2MouseJointDef,

function makeHexagon(world, x, y, userData) {
        // create block
        // This defines a hexagon in CCW order.
        // http://blog.sethladd.com/2011/09/box2d-and-polygons-for-javascript.html
        var bodyDef = new Box2D.Dynamics.b2BodyDef;
        bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
        bodyDef.userData = userData;
        bodyDef.position.Set(x,y);

        var fixDef = new Box2D.Dynamics.b2FixtureDef();
        fixDef.density = 6.0;
        fixDef.friction = 0.8;
        fixDef.restitution = 0.2;  //bouncing value
        fixDef.isSensor = false;
        scale = 0.75;
        var Mpoints = [     {x: 1*scale, y: 0},
                            {x: 1/2*scale, y: Math.sqrt(3)/2*scale},
                            {x: -1/2*scale, y:Math.sqrt(3)/2*scale},
                            {x: -1*scale, y:0},
                            {x: -1/2*scale, y: -Math.sqrt(3)/2*scale},
                            {x: 1/2*scale, y:-Math.sqrt(3)/2*scale} ];
        var points = Mpoints.map( function _makeVecBased( pt ) {
          return new Box2D.Common.Math.b2Vec2(2*pt.x, 2*pt.y);
        });

        fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape();
        fixDef.shape.SetAsArray(points, points.length);

        bodyDef.userData = 'moveable';
        var body = world.CreateBody(bodyDef);
        body.CreateFixture(fixDef);
        body.m_angularDamping = 1;
        body.m_linearDamping = 1;
        return body;
    }
function init()
{
    var test = localStorage.getItem("test"); //creates object for localStorage
    if (test == null) {
        if (testRobots) {
            test = {
                currentRun: 0,
                test: {//50,75,100,125,150
                    runs: [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 75,75, 75,75, 75,75, 75,75, 75,75,100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 125,125, 125,125, 125,125, 125,125, 125,125,150,150,150,150,150,150,150,150,150,150 ],
                    outcomes: []
                }
            }
        } else if (testNoise) { //changing brownian noise 0,.1,.5,1,5
            test = {
                currentRun: 0,
                test: {
                    runs: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, .1, .1, .1, .1, .1, .1, .1, .1, .1, .1, .5, .5, .5, .5, .5, .5, .5, .5, .5, .5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, ],
                    outcomes: []
                }
            }
        }
        localStorage.setItem("test", JSON.stringify(test));
    }
    ///////////////creating the main Regions
    mainMaps[0] = new Array(); //creating 3D array
    mainMaps[1] = new Array();
    mainMaps[2] = new Array();
    for (i = 0; i <= 20; i++) {
        mainMaps[0][i] = new Array();
        mainMaps[1][i] = new Array();
        mainMaps[2][i] = new Array();
    }
    for (i = 0; i <= 20; i++) { //setting the background to 0
        for (j = 0; j <= 20; j++) {
            mainMaps[0][i][j] = 0;
            mainMaps[1][i][j] = 0;
            mainMaps[2][i][j] = 0;
        }
    }
    //creating each mainRegion
    for (x = 1; x <= 20; x++) {
        for (y = 13; y <= 20; y++) {
            mainMaps[0][x][y] = 1;
        }
    }
    for (x = 1; x <= 20; x++) {
        for (y = 7; y < 13; y++) {
            mainMaps[1][x][y] = 1;
        }
    }
    for (x = 1; x <= 20; x++) {
        for (y = 1; y < 7; y++) {
            mainMaps[2][x][y] = 1;
        }
    }
    //creating the transfer Regions
    transferMaps[0] = new Array(); //creating 3D array
    transferMaps[1] = new Array();
    for (i = 0; i <= 20; i++) {
        transferMaps[0][i] = new Array();
        transferMaps[1][i] = new Array();
    }
    for (i = 0; i <= 20; i++) { //setting the background to 0
        for (j = 0; j <= 20; j++) {
            transferMaps[0][i][j] = 0;
            transferMaps[1][i][j] = 0;
        }
    }
    for (x = 15; x <= 20; x++) {
        for (y = 7; y <= 20; y++) {
            transferMaps[0][x][y] = 1;
        }
    }
    for (x = 1; x <= 4; x++) {
        for (y = 1; y < 13; y++) {
            transferMaps[1][x][y] = 1;
        }
    }
    //creating region status and control variables
    regionNum = 0;
    regionMain = true;
    var robotVar = false;
    var minRobotCount = null;
    var windowStopped = false;
    //variables for getting mean unstuck
    var prev_mean_position_x = 0; //previous mean positions of the block
    var prev_mean_position_y = 0;
    var start_timer = false; //starts timer for how long mean has been stuck
    var stop_timer = true;//stops timer for how long mean has been stuck
    var timer = 0;
    var timer_var = false;
    //////////////////////
	var b2Vec2 = Box2D.Common.Math.b2Vec2
	, b2AABB = Box2D.Collision.b2AABB
	, b2BodyDef = Box2D.Dynamics.b2BodyDef
	, b2Body = Box2D.Dynamics.b2Body
	, b2FixtureDef = Box2D.Dynamics.b2FixtureDef
	, b2Fixture = Box2D.Dynamics.b2Fixture
	, b2World = Box2D.Dynamics.b2World
	, b2MassData = Box2D.Collision.Shapes.b2MassData
	, b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
	, b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
	, b2DebugDraw = Box2D.Dynamics.b2DebugDraw
	, b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
	;
	var world = new b2World(
		new b2Vec2(0, 00) //gravity setting to zero removes gravity
		, true //allow sleep
		);
	var canvas = $('#canvas');
	var context = canvas.get(0).getContext('2d');
	var timeStart = null;
	var timeFinish = null;
	var timer = null;
	var passed = null;
	var overall_time = null;
	var firstloop = true;
	var boundaryHeight = 2;
	var boundaryWidth = 20;

	var fixDef = new b2FixtureDef;
	fixDef.density = 1.0;
	fixDef.friction = 0.5;
	fixDef.restitution = 0.25; //bouncing value
	var bodyDef = new b2BodyDef;

	//create enclosing boundary rectangles
	bodyDef.userData = 'obstacle';
	bodyDef.type = b2Body.b2_staticBody;
	fixDef.shape = new b2PolygonShape;
	fixDef.shape.SetAsBox(20, 2);//width, height
	bodyDef.position.Set(10, width / mapScale + 1); //bottom
	var bodyBottom = world.CreateBody(bodyDef);
	bodyBottom.CreateFixture(fixDef);
	bodyDef.position.Set(10, -1); //top
	world.CreateBody(bodyDef).CreateFixture(fixDef);
	fixDef.shape.SetAsBox(2, 14);//width, height
	bodyDef.position.Set(-1, 13); //left
	world.CreateBody(bodyDef).CreateFixture(fixDef);
	bodyDef.position.Set(21, 13); // right side
	world.CreateBody(bodyDef).CreateFixture(fixDef);

	// maze
	bodyDef.userData = 'obstacle';
		fixDef.shape.SetAsBox(10, 0.5);//width, height
    bodyDef.position.Set(15, width/4 / mapScale + 1.5); //TOP
    var bodyBottom = world.CreateBody(bodyDef);
    bodyBottom.CreateFixture(fixDef);

    bodyDef.position.Set(5, width*2/3 / mapScale + 0.2); //BOTTOM
    world.CreateBody(bodyDef).CreateFixture(fixDef);

    //create an object to move
    if (!MDP_DebugMode && !Gradient_DebugMode) {
        makeHexagon(world, 7, 15.5);
        bodyDef.userData = 'moveable';
        //try{
        //    fixDef.density = 6.0;
        //    fixDef.friction = 0.2;
        //    fixDef.restitution = 0.2;//bouncing value
        //    bodyDef = new b2BodyDef;
        //    bodyDef.type = b2Body.b2_dynamicBody;
        //    fixDef.shape = new b2PolygonShape;
        //    var points = [];

        //    var vec = new b2Vec2();
        //    vec.Set(1, 2);
        //    points[0] = vec;
        //    vec.Set(3, 5);
        //    points[1] = vec;
        //    vec.Set(1, 5);
        //    points[2] = vec;

        //    fixDef.shape.SetAsArray(points, points.length);
        //    bodyDef.position.Set(7,15.5);
        //    bodyDef.userData = 'moveable';
        //    world.CreateBody(this.bodyDef).CreateFixture(this.fixDef);

        //    //var obst = world.CreateBody(bodyDef);
        //    //obst.CreateFixture(fixDef);
        //    obst.m_angularDamping = 1;
        //    obst.m_linearDamping = 1;
        //}
        //catch (Exception){
        //    console.log("broken");
        //}

    }
	//create the robots
	bodyDef.type = b2Body.b2_dynamicBody;
	var robotrad = 0.15; //for SwarmControl.net, we used 0.2;
	var numrobots = 100;//Math.floor(20/(4*robotrad*robotrad));
	var totalRobots = 100;	//for regions calculations

	var CornerValuesX = [1, 19, 19, 1, 1, 100]; //variance corners
	var CornerValuesY = [19, 19, 7, 13, 1, 100];
	var CornerValuesD = [51, 41, 30, 24, 17, 100];
	if(MDP_DebugMode || Gradient_DebugMode)
	{
		numrobots = 0;
	}
	fixDef.density = 10.0;
	fixDef.friction = 2;
	fixDef.restitution = .5; //bouncing value
	fixDef.isSensor = false;
	var m_Robot = new Array();
	var rowLength = Math.floor(5/(2*robotrad));
	fixDef.shape = new b2CircleShape(robotrad );
	for(var i = 0; i < numrobots; ++i)
	{
		bodyDef.userData = 'robot';
		bodyDef.position.x = 1.5+(i%rowLength)*2*robotrad;
		bodyDef.position.y = 18.5-Math.floor(i/rowLength)*2*robotrad;
		m_Robot[i] = world.CreateBody(bodyDef);
		m_Robot[i].CreateFixture(fixDef);
		m_Robot[i].m_angularDamping = 1; //was 1, we used 10 on SwarmControl
		m_Robot[i].m_linearDamping = 1;
	}
	window.requestAnimFrame = (function()
	{
		return window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame  ||
		window.mozRequestAnimationFrame     ||
		window.oRequestAnimationFrame       ||
		window.msRequestAnimationFrame      ||
		function(/* function */ callback, /* DOMElement */ element){
			window.setTimeout(callback, 1000 / 60);
		};
	})();
	///////////////////////////////////
	var infinity = mapXSize * mapYSize;
	var mazeSize = 15;
	var mazeTopY = 13;
	var mazeDownY = 6;
	var goalPositionX = 16;
	var goalPositionY = 3;
	var goalPositionXDraw = 16.5;
	var goalPositionYDraw = 3.5;
	//giving -100 to boundaries

	if(ifBFS)
	{	//at the end, map[x][y] is the BFS distance to the goal
		for(var i = 0 ; i < mapXSize; i++){
			map[i][0]= -1;
			map[i][mapYSize -1] = -1;
			map[0][i]= -1;
			map[mapXSize-1][i]= -1;
		}
		// giving -1 to obstacles.(Down Maze)
		for (var i = 0 ; i < mazeSize; i++){
			map[i][mazeTopY]= -1;
		}
		//Top Maze
		for(var i = mapXSize-1 ; i > mapXSize- mazeSize -1 ; i--){
			map[i][mazeDownY] = -1;
		}
		for (var i = 0 ; i < mapXSize ; i++){
			for (var j = 0 ; j < mapYSize; j++){
				if(map[i][j] != -1)
				{
					map[i][j]= infinity;
				}
			}
		}
		map[goalPositionX][goalPositionY] = 0;
		BFS(goalPositionX, goalPositionY);
		ifBFS = false;
	}

	if(ifMDP)
	{
		for(var i = 0 ; i < mapXSize; i++){
			map_MDP[i][0]= -100;
			map_MDP[i][mapYSize-1] = -100;
			map_MDP[0][i]= -100;
			map_MDP[mapXSize-1][i]= -100;

			map_R[i][0]= -50;
			map_R[i][mapYSize -1] = -50;
			map_R[0][i]= -50;
			map_R[mapXSize-1][i]= -50;

			map_prev[i][0]= 0;
			map_prev[i][mapYSize -1] = 0;
			map_prev[0][i]= 0;
			map_prev[mapXSize-1][i]= 0;

		}
		// giving -100 to obstacles.(Down Maze)
		for (var i = 0 ; i < mazeSize; i++){
			map_MDP[i][mazeTopY]= -100;
			map_R[i][mazeTopY]= -50;
			map_prev[i][mazeTopY] = 0;
		}
		//Top Maze
		for(var i = mapXSize-1 ; i > mapXSize- mazeSize-1  ; i--){
			map_MDP[i][mazeDownY] = -100;
			map_R[i][mazeDownY] = -50;
			map_prev[i][mazeDownY] = 0;
		}

		for (var i = 0 ; i < mapXSize ; i++){
			for (var j = 0 ; j < mapYSize; j++){
				if(map_MDP[i][j] != -100)
				{
					map_MDP[i][j]= -1;
					map_R[i][j] = -1;
					map_prev[i][j] = 0;
				}
			}

		}
        map_MDP[goalPositionX][goalPositionY] = 100;
		map_R[goalPositionX][goalPositionY] = 100;

		while( (iteration < iteration_limit)){
			map_prev = map_MDP;
			for (var i = 0; i < mapXSize; i++){
				for(var j = 0; j < mapYSize; j++){
					if (map_MDP[i][j] != -100){
						policy_MDP(i, j);
						map_MDP[i][j] = gamma * (map_R[i][j] + bestpayoff);
						policy_x[i][j] = -bestmove[0];
						policy_y[i][j] = -bestmove[1];

						policy_angle[i][j] = Math.atan2(policy_y[i][j],policy_x[i][j] ) * 180 / Math.PI + 270;

					}
				}
			}
			iteration++;
		}
		ifMDP = false;
	}

	if(ifGradient)
	{	//for each cell, calculate the gradient
		for(var i = 0 ; i < mapXSize; i ++){
			for(var j = 0 ; j <mapYSize; j++)
			{
				Gradient(i,j);
			}
		}
		ifGradient = false;
	}

	(function animloop()
	{
		requestAnimFrame(animloop);
		update();
	})();
	if ( timeStart == null){
		var day = new Date();
		timeStart= day.getTime();
	}
	function lineDistance( x1,y1,x2,y2){
		var xs = 0;
		var ys = 0;
		xs = x1 - x2;
		xs = xs * xs;
		ys = y1 - y2;
		ys = ys * ys;
		return Math.sqrt( xs + ys );
	}

	//called each animation round
    //y-axis is inverted in webpage
	var hasLoggedData = false; //control variable for localStorage
	function update()
	{
		var impulseV=new b2Vec2(0,0);
		var impulse = 3.0;
		if(m_controlState & ROBOT_INPUT.ROBOT_PROP)
		{
			impulseV.x = m_ControlInputX;
			impulseV.y = m_ControlInputY;
		}
		//apply Brownian noise:
		var brownianImpulse = new b2Vec2(0,0);
		var mag = 0;
		var ang = 0;
		var vary = 25; //was 25
		if (testing) {//getting values to run simulations
		    var inputTest = JSON.parse(localStorage.getItem("test"));
		    if (inputTest.currentRun >= 50) {
		        window.close();
		        console.log("window stopped");
		        windowStopped = true;
		    } else {
		        var value = JSON.parse(inputTest.test.runs[inputTest.currentRun]);
		        if (testRobots) {
		            numrobots = value; //getting value for robots
		            totalRobots = value;
		        } else if (testNoise) {
		            vary = value; //getting value for brownian noise
		            numrobots = 100; //getting value for robots
		            totalRobots = 100;
		        }
		    }
		}
		for(var i =0; i<m_Robot.length; i++)
		{
			mag = vary * Math.random();
			ang = 2*Math.PI*Math.random();
			brownianImpulse.x = mag*Math.cos(ang) + impulseV.x ;
			brownianImpulse.y = mag*Math.sin(ang) + impulseV.y ;
			m_Robot[i].ApplyForce(brownianImpulse,m_Robot[i].GetWorldPoint(new b2Vec2(0,0)));
		}
		world.Step(1 / 60, 10, 10);
		world.DrawDebugData();
		world.ClearForces();
		$("canvas").clearCanvas();
		$("canvas").rotateCanvas(
		{
			x: 5 * mapScale, y: 5 * mapScale,
			rotate: angle
		}).drawArc(
		{
			fillStyle: "green",
			x: 5 * mapScale, y: 5 * mapScale,
			radius: radius * mapScale
		}).drawArc(
		{
			strokeStyle: 'red',
			strokeWidth: 16, //fillStyle: "green",
			x: goalPositionXDraw * mapScale, y: goalPositionYDraw * mapScale,
			radius: 2.0 * mapScale
		}).drawText(
		{
			strokeStyle: "green",
			strokeWidth: 2,
			x: goalPositionXDraw*mapScale  , y: goalPositionYDraw *mapScale ,
			fontSize: 20,
			fontFamily: 'Verdana, sans-serif',
			text: "Goal"
		}).restoreCanvas();

		if(MDP_DebugMode)
		{
			for(var i = 0 ; i < mapXSize; i++)
				for (var j = 0 ; j < mapYSize; j++)
				{
					if(map_MDP[i][j] != 100 && map_MDP[i][j] != 52){
						$("canvas").drawText(
						{
							strokeStyle: 'green',
							strokeWidth: 2,
							x: (i+ 0.5)*mapScale  , y: (j+0.5) *mapScale ,
							fontSize: 20,
							fontFamily: 'Verdana, sans-serif',
							text: Math.round(map_MDP[i][j]/10-36)
						});
					}
					else if (map_MDP[i][j] == 100 )
					{
						$("canvas").drawText(
						{
							strokeStyle: "brown",
							strokeWidth: 2,
							x: (i+ 0.5)*mapScale  , y: (j+0.5) *mapScale ,
							fontSize: 20,
							fontFamily: 'Verdana, sans-serif',
							text: map_MDP[i][j]
						});
					}
				}
		}

		if(Gradient_DebugMode_MDP)
		{
			for(var i = 0 ; i < mapXSize; i++){
				for (var j = 0 ; j < mapYSize; j++){
					$('canvas').drawVector({
						strokeStyle: '#000',
						strokeWidth: 2,
						rounded: true,
						endArrow: true,
						arrowRadius: 10,
						arrowAngle: 30,
						x: mapScale* (i+ 0.5  + 0.5*Math.cos((90+policy_angle[i][j])*Math.PI/180.0))	 , y: mapScale * (j + 0.5 + 0.5*Math.sin((90+policy_angle[i][j])*Math.PI/180.0)),
						a1: policy_angle[i][j], l1: mapScale
					});
				}
			}
		}

		if(BFSDebugMode)
		{
			for(var i = 0 ; i < mapXSize; i++)
				for (var j = 0 ; j < mapYSize; j++)
				{
					if(map[i][j] != 0 && map[i][j] != 52){
						$("canvas").drawText(
						{
							strokeStyle: '#25a',
							strokeWidth: 2,
							x: (i+ 0.5)*mapScale  , y: (j+0.5) *mapScale ,
							fontSize: 20,
							fontFamily: 'Verdana, sans-serif',
							text: map[i][j]
						});
					}
					else if (map[i][j] == 0 )
					{
						$("canvas").drawText(
						{
							strokeStyle: "yellow",
							strokeWidth: 2,
							x: (i+ 0.5)*mapScale  , y: (j+0.5) *mapScale ,
							fontSize: 20,
							fontFamily: 'Verdana, sans-serif',
							text: map[i][j]
						});
					}
					else if (map[i][j] == 52)
					{
						$("canvas").drawText({
							strokeStyle: "yellow",
							strokeWidth: 2,
							x: (i+ 0.5)*mapScale  , y: (j+0.5) *mapScale ,
							fontSize: 20,
							fontFamily: 'Verdana, sans-serif',
							text: map[i][j]
						});
					}
				}
		}
		if(Gradient_DebugMode)
		{
			for(var i = 0 ; i < mapXSize; i++){
				for (var j = 0 ; j < mapYSize; j++){
					$('canvas').drawVector({
						strokeStyle: '#000',
						strokeWidth: 2,
						rounded: true,
						endArrow: true,
						arrowRadius: 10,
						arrowAngle: 30,
						x: mapScale* (i+ 0.5  + 0.5*Math.cos((90+gradient_angle[i][j])*Math.PI/180.0))	 , y: mapScale * (j + 0.5 + 0.5*Math.sin((90+gradient_angle[i][j])*Math.PI/180.0)),
						a1: gradient_angle[i][j], l1: mapScale
					});
				}
			}
		}

    function _drawRobot( x, y, angle,radius ) {
      $("canvas").rotateCanvas(
      {
        x: x * mapScale, y: y * mapScale,
        rotate: angle
      })
      .drawArc(
      {
        strokeStyle: "lightblue",
        strokeWidth: 1,
        fillStyle: "blue",
        x: x * mapScale, y: y * mapScale,
        radius: radius * mapScale
      })
      .restoreCanvas();
    }

		//draw robots and obstacles
		for (b = world.GetBodyList() ; b; b = b.GetNext())
		{
			var angle = b.GetAngle()*(180/Math.PI);
      var userData = b.GetUserData();
      var pos = b.GetPosition();
			for(f = b.GetFixtureList(); f; f = f.GetNext())
			{
				if ( userData == 'robot')
				{
					var radius = f.GetShape().GetRadius();
          _drawRobot( pos.x, pos.y, angle, radius );
				}
				else if (userData == 'obstacle' || userData  == 'moveable' || userData == 'rectangle_ground')
				{
					var X = f.GetShape().GetVertices()[1].x - f.GetShape().GetVertices()[0].x;
					var Y = f.GetShape().GetVertices()[2].y - f.GetShape().GetVertices()[1].y;
          if(userData == 'moveable') {
						var color = 'black';
						blockCOM_x = pos.x;
						blockCOM_y = pos.y;

            //continue;
            $("canvas")
            .rotateCanvas({
  						x: pos.x * mapScale, y: pos.y * mapScale,
  						rotate: angle
  					})
            .drawPolygon({
               fillStyle: color,
               x: pos.x * mapScale, y: pos.y * mapScale,
               radius: 1.5*mapScale,
               sides: 6,
               rotate: angle || 0
            })
  					.restoreCanvas();
            continue;


					} else if(userData == 'rectangle_ground') {
              var color = 'green';
          } else if(userData == 'obstacle') {
            var color = 'brown';
          }

					$("canvas").rotateCanvas({
						x: pos.x * mapScale, y: pos.y * mapScale,
						rotate: angle
					})
					.drawRect({
						fillStyle: color,
						x: pos.x * mapScale, y: pos.y * mapScale,
						width: X * mapScale,
						height: Y * mapScale,
						cornerRadius: 0
					})
					.restoreCanvas();

          if(MDP_DebugMode || Gradient_DebugMode_MDP){
						for(var i = 0 ; i < 20; i++)
						{
              break;
							$("canvas").drawLine(
							{
								strokeStyle: 'gray',
								strokeWidth: 1,
								x1: i*mapScale, y1: 0,
								x2: i*mapScale, y2: 20*mapScale
							})
							.drawLine({
								strokeStyle: 'gray',
								strokeWidth: 1,
								x1: 0, y1: i*mapScale,
								x2: 20*mapScale, y2: i*mapScale
							})
						}
						$("canvas").restoreCanvas();
					}
				}
			}
		}

		if(!goalRecieved){
			$("canvas")
			.drawArc({
			//draw the goal mean position
			strokeStyle: "lightblue",
			strokeWidth: 5,
			x: goalX * mapScale, y: goalY * mapScale,
			radius: radius * mapScale
		}).drawArc({
			//draw the goal mean position
			strokeStyle: "lightblue",
			strokeWidth: 5,
			x: goalX * mapScale, y: goalY * mapScale,
			radius: (radius + 0.2) * mapScale
		}).restoreCanvas();
		}
		$("canvas").drawArc({
			//COM of the block
			strokeStyle: "orange",
			strokeWidth: 5,
			x: blockCOM_x * mapScale, y: blockCOM_y * mapScale,
			radius: radius * mapScale
		})
		.restoreCanvas();

		var day = new Date();
		if( timeFinish == null && false)
			{ timeFinish = day.getTime();}
		if(overall_time == null) // set the start time
		{
			overall_time = day.getTime();
			goalStartTime = day.getTime();
		}
		var elapsedTimeSec = (day.getTime()- overall_time )/1000;

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// CONTROLLER
		///////////////////////////////////////////////////////////////////////////////////////////////////////////
		//goal positions
		var cycleInSec = 20;
		var amplitudeY = 5;
		var offsetY = 5;
		var amplitudeX = 5;
		var offsetX = 5;

		var sum_position_x = 0;
		var sum_position_y = 0;
		var sum2_x = 0;
		var sum2_y = 0;
		var desired_var_x;
		var cov_xy = 0;
		var block_x = Math.floor(blockCOM_x);
		var block_y = Math.floor(blockCOM_y);
		if (isNaN(block_y)) {
		    var state = JSON.parse(localStorage.getItem("test"));
		    //alert(JSON.stringify(state));
		    state.test.outcomes[state.currentRun] = blockCOM_y+" NaN";
		    state.currentRun++;
		    localStorage.setItem("test", JSON.stringify(state));
		    hasLoggedData = true;
		    location.reload(true);
		}
	////////////switching regions
		if (regionMain) {
			var blockPosition = mainMaps[regionNum][block_x][block_y];
		}
		if (!regionMain) {
			var blockPosition = transferMaps[regionNum][block_x][block_y];
		}
		if (blockPosition == 0) {
			if (regionMain) {//if it's in the main region
				regionMain = false; //switch to transfer regions
				if (transferMaps[0][block_x][block_y] == 1) {
					regionNum = 0; //checking which region the block is in
				}
				else if (transferMaps[1][block_x][block_y] == 1) {
					regionNum = 1;
				}
			}else if (!regionMain) {
				regionMain = true;
				if (mainMaps[0][block_x][block_y] == 1) {
					regionNum = 0;
				}else if (mainMaps[1][block_x][block_y] == 1) {
					regionNum = 1;
				} else if (mainMaps[2][block_x][block_y] == 1) {
					regionNum = 2;
				}
			}
		}
		numrobots = totalRobots;
		var regionRobotCount = 0;
		if (regionMain) {
			for (var i = 0; i < numrobots; ++i) {
				var pos_x = Math.floor(m_Robot[i].GetPosition().x);
				var pos_y = Math.floor(m_Robot[i].GetPosition().y);
				var pos = mainMaps[regionNum][pos_x][pos_y];
				if (pos == 1) {
					sum_position_x += m_Robot[i].GetPosition().x;
					sum_position_y += m_Robot[i].GetPosition().y;
					regionRobotCount=regionRobotCount+1;
				}
			}
		}
		if (!regionMain) {
			for (var i = 0; i < numrobots; ++i) {
				var pos_x = Math.floor(m_Robot[i].GetPosition().x);
				var pos_y = Math.floor(m_Robot[i].GetPosition().y);
				var pos = transferMaps[regionNum][pos_x][pos_y];
				if (pos == 1) {
					sum_position_x += m_Robot[i].GetPosition().x;
					sum_position_y += m_Robot[i].GetPosition().y;
					regionRobotCount = regionRobotCount + 1;
				}
			}
		}
		numrobots = regionRobotCount;
		//console.log("regionRobotCount " + regionRobotCount);
		var mean_position_x = sum_position_x / numrobots;
		var mean_position_y = sum_position_y / numrobots;
			//calculating cov
		if (regionMain) {
			for (var i = 0; i < numrobots; ++i) {
				var pos_x = Math.floor(m_Robot[i].GetPosition().x);
				var pos_y = Math.floor(m_Robot[i].GetPosition().y);
				var pos = mainMaps[regionNum][pos_x][pos_y];
				if (pos == 1) {
					sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
					sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
					cov_xy = cov_xy + (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().y - mean_position_y) / numrobots;
				}
			}
		}
		if (!regionMain) {
			for (var i = 0; i < numrobots; ++i) {
				var pos_x = Math.floor(m_Robot[i].GetPosition().x);
				var pos_y = Math.floor(m_Robot[i].GetPosition().y);
				var pos = transferMaps[regionNum][pos_x][pos_y];
				if (pos == 1) {
					sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
					sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
					cov_xy = cov_xy + (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().y - mean_position_y) / numrobots;
				}
			}
		}
		max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
		min_desired_var_x = numrobots * robotrad * min_desired_var_x_constant; //was .663
		max_desired_var_y = max_desired_var_x;
		min_desired_var_y = min_desired_var_x;

		var var_x = sum2_x / numrobots;
		var var_y = sum2_y / numrobots;
		var diffeq = Math.sqrt( (var_x-var_y)*(var_x-var_y)/4 + cov_xy*cov_xy);
		var var_xp = (var_x+var_y)/2 + diffeq;
		var var_yp = (var_x+var_y)/2 - diffeq;
		var angle2 = 180/Math.PI*1/2*Math.atan2( 2*cov_xy, var_x-var_y);
		var angle_min_variance = 180/Math.PI*1/2*Math.atan2( 2*cov_xy, min_desired_var_x-min_desired_var_y);
		var angle_max_variance = 180/Math.PI*1/2*Math.atan2( 2*cov_xy, max_desired_var_x-max_desired_var_y);
		var index_x = Math.floor(mean_position_x);
		var index_y = Math.floor(mean_position_y);

		//finds the adjacent region with the most robots
		var count1 = 0;
		var count2 = 0;
		var adjCount = 0;

		var adj1 = findAdjRegion(regionMain, regionNum, 0); //grabs the regions
		var adj2 = findAdjRegion(regionMain, regionNum, 1);
		if (adj2 == null) {
			if (regionRobotCount>adj1){
				robotMain = regionMain;
				mostRobotRegion = regionNum;
			} else {
				mostRobotRegion = adj1;
				mostRobotRegion = !regionNum;
			}
		} else { //counts robots in each adjacent region
			for (i = 0; i < totalRobots; i++) {
				var pos_x = Math.floor(m_Robot[i].GetPosition().x);
				var pos_y = Math.floor(m_Robot[i].GetPosition().y);
				if (regionMain) {
					var pos1 = transferMaps[adj1][pos_x][pos_y];
					if (pos1 == 1) { //check if robot's in 1st adjacent region
						count1++;
					}
					var pos2 = transferMaps[adj2][pos_x][pos_y];
					if (pos2 == 1) {
						count2++;
					}
				}
				if (!regionMain) {
					var pos1 = mainMaps[adj1][pos_x][pos_y];
					if (pos1 == 1) {
						count1++;
					}
					var pos2 = mainMaps[adj2][pos_x][pos_y];
					if (pos2 == 1) {
						count2++;
					}
				}
			}
			if ((regionRobotCount>count1)&&(regionRobotCount>count2)) { //if regionNum has the most robots
				robotMain=regionMain;
				mostRobotRegion=regionNum;
			}else if ((count1>regionRobotCount)&&(count1>count2)){ //if adj1 has the most robots
				robotMain=!regionMain; //the robots has the opposite map from the obj
				mostRobotRegion=adj1;
			}else if((count2>regionRobotCount)&&(count2>count1)){
				robotMain=!regionMain; //the robots has the opposite map from the obj
				mostRobotRegion=adj2;
			}
		}
		if (totalRobots == 10) {
		    minRobotCount = 4;
		} else if (totalRobots == 20) {
		    minRobotCount = 6;
		} else minRobotCount = 10;
		if (regionRobotCount < minRobotCount) {
		    robotVar = true;
		}
		if (robotVar) {
		    var cornerCali = findRegionBasedVar(regionMain, regionNum, robotMain, mostRobotRegion);
		    IndexMinDist = cornerCali;
		    goalX = CornerValuesX[IndexMinDist];
		    goalY = CornerValuesY[IndexMinDist];
		    robotCornerCount=0;
		    for (i = 0; i < totalRobots; i++) {
		        var robot2CornerDistX = CornerValuesX[IndexMinDist] - m_Robot[i].GetPosition().x;
		        var robot2CornerDistY = CornerValuesY[IndexMinDist] - m_Robot[i].GetPosition().y;
		        var normalizedDist = Math.sqrt(Math.pow(robot2CornerDistX, 2) + Math.pow(robot2CornerDistY, 2));
		        if (normalizedDist <4   ) {
		            robotCornerCount++; //counts robots in corner
		        }
		    }
		    if (robotCornerCount => minRobotCount || robotCornerCount == regionRobotCount) {
		        robotVar = false;
		    }

		}
	    //for init- prev mean pos, start_timer=false, stop_timer=true; var timer=0;
	    //for global var prev_mean pos
	    //variance control if the mean stays in the same place 
		var prev_block_mean_difference = null;
		if (stop_timer) {
		    timer = 0;
		    start_timer = true; //starts timer
		    stop_timer = false;
		}
		if (start_timer) {
		    timer = elapsedTimeSec; //gets starting point
		    prev_block_mean_difference = Math.floor(lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y));
		    var block_difference = lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y);
		    start_timer = false;
		}
		if ((elapsedTimeSec - timer) > 10) {
		    var block_mean_difference = Math.floor(lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y));
		    if ((block_difference<4) && (Math.abs(block_mean_difference-prev_block_mean_difference)<.1)) {
		        flagVar = true;
		        timer_var = true;
		        stop_timer = true;
		    } else {
		        stop_timer = true; //stops timer
		        timer_var = false; 
		    }
		}

		////////////////////////////////
		if(!goalRecieved){
			$("canvas").drawEllipse({
				strokeStyle: "red",
				strokeWidth: 5,
				setLineDash: 6 ,
				x: mean_position_x* mapScale, y: mean_position_y * mapScale,
				width: 3 * 30*Math.sqrt(var_xp), height: 3 * 30*Math.sqrt(var_yp),
				rotate: angle2
			})
			.restoreCanvas();
		}else{
		    var winstring = "Success,\n " + totalRobots + " robots in " + Math.floor(timeFinished) + "s";
		    goalRecieved = true;
			$("canvas").drawText(
			{
				strokeStyle: "blue",
				strokeWidth: 4,
				x: 9*mapScale  , y: 10 *mapScale ,
				fontSize: 40,
				fontFamily: 'Verdana, sans-serif',
				text: winstring
			}).restoreCanvas();
		}
		if(Math.abs(blockCOM_x - goalPositionX) < 2 && Math.abs(blockCOM_y - goalPositionY) <2)
		{
			goalRecieved = true;

			if(wroteFinish == false){
				timeFinished = elapsedTimeSec;
				wroteFinish = true;
			}
			m_controlState  = ROBOT_INPUT.ROBOT_IDLE;
		}
		
		if (!goalRecieved) {
		    if (timer_var) {
		        min_desired_var_x = .1;
		        min_desired_var_y = min_desired_var_x;
		        console.log("MIN VARR :" + min_desired_var_x);
		    } else {
		        max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
		        min_desired_var_x = numrobots * robotrad * min_desired_var_x_constant; //was .663
		        max_desired_var_y = max_desired_var_x;
		        min_desired_var_y = min_desired_var_x;
            }
    
			if(var_x < min_desired_var_x && var_y < min_desired_var_y)
			{
				flagVar = false;
			}
			if(var_x > max_desired_var_x || var_y > max_desired_var_y)
			{
				flagVar = true;
			}
			if(flagVar)
			{
				var dist2corner = new Array(CornerValuesX.length);
				var COMdist2corner = new Array(CornerValuesX.length);
				var minDistCorner = 10000;
				var IndexMinDist = 0;
				for (var i = 0 ; i < CornerValuesX.length ; i++)
				{	//computes distance from all corners to COM  and swarm mean.  Also records closest corner to  mean of swarm
					dist2corner[i] = lineDistance(mean_position_x, mean_position_y, CornerValuesX[i], CornerValuesY[i]);
					COMdist2corner[i] = lineDistance(blockCOM_x, blockCOM_y, CornerValuesX[i], CornerValuesY[i]);
					if(minDistCorner > dist2corner[i])
					{
						minDistCorner = dist2corner[i];
						IndexMinDist = i;
					}
				}
				if(   CornerValuesD[IndexMinDist] <  map[block_x][block_y]  && IndexMinDist>0 )
				{
				    IndexMinDist = IndexMinDist - 1;
				}
				var cornerCali = findRegionBasedVar(regionMain, regionNum, robotMain, mostRobotRegion);//finds corner based on regions
				IndexMinDist = cornerCali;
				goalX = mean_position_x + Math.cos(Math.atan2(CornerValuesY[IndexMinDist]-mean_position_y,CornerValuesX[IndexMinDist]-mean_position_x));
				goalY = mean_position_y + Math.sin(Math.atan2(CornerValuesY[IndexMinDist]-mean_position_y,CornerValuesX[IndexMinDist]-mean_position_x));
			}
			if(!flagVar)
			{
				var r = 0.8;
				alphaWant = Math.atan2(policy_y[block_x][block_y],policy_x[block_x][block_y]);

				attPointX=blockCOM_x - r * Math.cos(alphaWant+Math.PI);
				attPointY=blockCOM_y - r * Math.sin(alphaWant+Math.PI);
				repPointX=blockCOM_x;
				repPointY=blockCOM_y;
				if (1000 < day.getTime()-goalStartTime||firstloop){
					rho=lineDistance(mean_position_x, mean_position_y,repPointX,repPointY);

					inside = inside + 1;

					theta = Math.atan2(mean_position_y - repPointY,mean_position_x - repPointX);
					angdiff = alphaWant-theta;
					if(angdiff > Math.PI) {angdiff = angdiff - 2*Math.PI};
					if(angdiff < -Math.PI) {angdiff = angdiff + 2*Math.PI};
					var CGoal = 1;

					if((rho<rhoNot&&Math.abs(angdiff)>(goalAngle))&&!robotVar)
					{
						FrepX = eta*((1/rho)-(1/rhoNot))*(1/rho)*(1/rho)*(repPointX - mean_position_x);//change these lines
						FrepY = eta*((1/rho)-(1/rhoNot))*(1/rho)*(1/rho)*(repPointY - mean_position_y);
						rho=lineDistance(mean_position_x, mean_position_y,attPointX,attPointY);
						FattX = zeta*(mean_position_x - attPointX)/rho;//change these lines
						FattY = zeta*(mean_position_y - attPointY)/rho;
						distX =  -CGoal*Math.cos(Math.atan2(FattY+FrepY,FattX+FrepX));
						distY =  -CGoal*Math.sin(Math.atan2(FattY+FrepY,FattX+FrepX));
						max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
						max_desired_var_y = max_desired_var_x;
					}else if(!robotVar){
						var COMdist2swarm = lineDistance(blockCOM_x, blockCOM_y, mean_position_x, mean_position_y);
						if (COMdist2swarm < 1.5) {
							var r = 0.1;
						}else var r = 0.8;
						distX = CGoal*Math.cos(Math.atan2(blockCOM_y + r * policy_y[block_x][block_y]-mean_position_y,blockCOM_x + r * policy_x[block_x][block_y]-mean_position_x));
						distY = CGoal*Math.sin(Math.atan2(blockCOM_y + r * policy_y[block_x][block_y]-mean_position_y,blockCOM_x + r * policy_x[block_x][block_y]-mean_position_x));
						max_desired_var_x = numrobots * robotrad * max_desired_var_x_constant;//numrobots * robotrad * .20; //was 1.91
						max_desired_var_y = max_desired_var_x;
					}
					goalStartTime=day.getTime();
				}
				goalX = mean_position_x + distX;
				goalY = mean_position_y + distY;
			}
			string = "Time = "+ elapsedTimeSec +"s<br>inside # "+ inside;
			$('#cc').html(string); //USERDATA WILL SHOWN IN "div" WITH ID "cc"

			$("canvas").drawArc({ //draw the average position
				strokeStyle: "red",
				strokeWidth: 5,
				x: mean_position_x* mapScale, y: mean_position_y * mapScale,
				radius: radius * mapScale
			})
			.drawEllipse({
				strokeStyle: "green",
				strokeWidth: 5,
				setLineDash: 6 ,
				x: mean_position_x* mapScale, y: mean_position_y * mapScale,
				width: 3 * 30*Math.sqrt(min_desired_var_x), height: 3 * 30*Math.sqrt(min_desired_var_y),
				rotate: angle2
			})
			.drawEllipse({
				strokeStyle: "green",
				strokeWidth: 5,
				setLineDash: 6 ,
				x: mean_position_x* mapScale, y: mean_position_y * mapScale,
				width: 3 * 30*Math.sqrt(max_desired_var_x), height: 3 * 30*Math.sqrt(max_desired_var_y),
				rotate: angle2
			}).restoreCanvas();
			var Kgain = 10; //faster=bigger
			var Kderivative = 1; //smaller=faster
			var sum_velocity_x = 0;
			var sum_velocity_y = 0;
			for(var i = 0; i < numrobots; ++i) {
				sum_velocity_x += m_Robot[i].GetLinearVelocity().x;
				sum_velocity_y += m_Robot[i].GetLinearVelocity().y;
			}
			var mean_velocity_x = sum_velocity_x / numrobots;
			var mean_velocity_y = sum_velocity_y / numrobots;
			m_ControlInputY = Kgain*(goalY - mean_position_y) + Kderivative*(0-mean_velocity_y) ;
			m_ControlInputX = Kgain*(goalX - mean_position_x) + Kderivative*(0-mean_velocity_x) ;
			m_controlState = ROBOT_INPUT.ROBOT_PROP;
		}
		if (goalRecieved && !hasLoggedData && testing) { //stores game time
		    var state = JSON.parse(localStorage.getItem("test"));
		    // alert(JSON.stringify(state));
		    state.test.outcomes[state.currentRun] = elapsedTimeSec;
		    hasLoggedData = true;
		    location.reload(true);
		    state.currentRun++;
		    localStorage.setItem("test", JSON.stringify(state));
		} else if ((elapsedTimeSec > 1200) && testing) { //runtime error
		    var state = JSON.parse(localStorage.getItem("test"));
		    //alert(JSON.stringify(state));
		    state.test.outcomes[state.currentRun] = state.test.runs[state.currentRun] + " run time error";
		    hasLoggedData = true;
		    location.reload(true);
		    state.currentRun++;
		    localStorage.setItem("test", JSON.stringify(state));
		}
		if (DrawForce_DebugMode) {
		    for (var i = 0 ; i < mapXSize; i++) {
		        for (var j = 0 ; j < mapYSize; j++) {
		            rho = lineDistance((i + 0.5), (j + 0.5), attPointX, attPointY);
		            FattX = zeta * ((i + 0.5) - attPointX) / rho;//change these lines
		            FattY = zeta * ((j + 0.5) - attPointY) / rho;

		            rho = lineDistance((i + 0.5), (j + 0.5), repPointX, repPointY)
		            theta = Math.atan2((j + 0.5) - repPointY, (i + 0.5) - repPointX);
		            angdiff = alphaWant - theta;
		            if (angdiff > Math.PI) { angdiff = angdiff - 2 * Math.PI };
		            if (angdiff < -Math.PI) { angdiff = angdiff + 2 * Math.PI };

		            if (rho < rhoNot && Math.abs(angdiff) > (goalAngle)) {
		                FrepX = eta * ((1 / rho) - (1 / rhoNot)) * (1 / rho) * (1 / rho) * (repPointX - (i + 0.5));//change these lines
		                FrepY = eta * ((1 / rho) - (1 / rhoNot)) * (1 / rho) * (1 / rho) * (repPointY - (j + 0.5));
		                $('canvas').drawVector({
		                    strokeStyle: '#000',
		                    strokeWidth: 2,
		                    rounded: true,
		                    endArrow: true,
		                    arrowRadius: 10,
		                    arrowAngle: 30,
		                    x: mapScale * (i + 0.5 + 0.5 * Math.cos(Math.atan2(FattY + FrepY, FattX + FrepX))), y: mapScale * (j + 0.5 + 0.5 * Math.sin(Math.atan2(FattY + FrepY, FattX + FrepX))),
		                    a1: (Math.atan2(FattY + FrepY, FattX + FrepX) * 180 / Math.PI) + 270, l1: mapScale // Fact, I don't know why Shiva has a plus 270 in her code here... but I added it
		                });
		            }
		            else {
		                FrepX = 0;
		                FrepY = 0;
		            }
		        }
		    }
		}
		if (firstloop){firstloop=false;}
	}; //end update
};
</script>
<style>
    #cc {
        top: 600px;
        width: 600px;
        height: 200px;
        margin: 0;
        overflow: auto;
    }
</style>
</html>
